{"version":3,"sources":["../src/index.js"],"names":["throwError","isNodePattern","Resize","Resize2","constants","RESIZE_NEAREST_NEIGHBOR","RESIZE_BILINEAR","RESIZE_BICUBIC","RESIZE_HERMITE","RESIZE_BEZIER","class","resize","w","h","mode","cb","call","constructor","AUTO","bitmap","width","height","Math","round","dst","data","Buffer","alloc","image","buffer","from"],"mappings":"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","sourcesContent":["import { throwError, isNodePattern } from '@jimp/utils';\n\nimport Resize from './modules/resize';\nimport Resize2 from './modules/resize2';\n\nexport default () => ({\n  constants: {\n    RESIZE_NEAREST_NEIGHBOR: 'nearestNeighbor',\n    RESIZE_BILINEAR: 'bilinearInterpolation',\n    RESIZE_BICUBIC: 'bicubicInterpolation',\n    RESIZE_HERMITE: 'hermiteInterpolation',\n    RESIZE_BEZIER: 'bezierInterpolation'\n  },\n\n  class: {\n    /**\n     * Resizes the image to a set width and height using a 2-pass bilinear algorithm\n     * @param {number} w the width to resize the image to (or Jimp.AUTO)\n     * @param {number} h the height to resize the image to (or Jimp.AUTO)\n     * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp} this for chaining of methods\n     */\n    resize(w, h, mode, cb) {\n      if (typeof w !== 'number' || typeof h !== 'number') {\n        return throwError.call(this, 'w and h must be numbers', cb);\n      }\n\n      if (typeof mode === 'function' && typeof cb === 'undefined') {\n        cb = mode;\n        mode = null;\n      }\n\n      if (w === this.constructor.AUTO && h === this.constructor.AUTO) {\n        return throwError.call(this, 'w and h cannot both be set to auto', cb);\n      }\n\n      if (w === this.constructor.AUTO) {\n        w = this.bitmap.width * (h / this.bitmap.height);\n      }\n\n      if (h === this.constructor.AUTO) {\n        h = this.bitmap.height * (w / this.bitmap.width);\n      }\n\n      if (w < 0 || h < 0) {\n        return throwError.call(this, 'w and h must be positive numbers', cb);\n      }\n\n      // round inputs\n      w = Math.round(w);\n      h = Math.round(h);\n\n      if (typeof Resize2[mode] === 'function') {\n        const dst = {\n          data: Buffer.alloc(w * h * 4),\n          width: w,\n          height: h\n        };\n        Resize2[mode](this.bitmap, dst);\n        this.bitmap = dst;\n      } else {\n        const image = this;\n        const resize = new Resize(\n          this.bitmap.width,\n          this.bitmap.height,\n          w,\n          h,\n          true,\n          true,\n          buffer => {\n            image.bitmap.data = Buffer.from(buffer);\n            image.bitmap.width = w;\n            image.bitmap.height = h;\n          }\n        );\n        resize.resize(this.bitmap.data);\n      }\n\n      if (isNodePattern(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    }\n  }\n});\n"],"file":"index.js"}