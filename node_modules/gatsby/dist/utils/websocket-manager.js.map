{"version":3,"sources":["../../src/utils/websocket-manager.js"],"names":["path","require","store","fs","pageDataUtil","normalizePagePath","telemetry","url","createHash","denormalize","undefined","charAt","length","getCachedPageData","pagePath","directory","program","pages","getState","publicDir","join","has","pageData","read","result","id","err","Error","hashPaths","paths","map","update","digest","getCachedStaticQueryResults","resultsMap","cachedStaticQueryResults","Map","staticQueryComponents","forEach","staticQueryComponent","hash","filePath","fileResult","readFileSync","console","log","componentPath","set","JSON","parse","getRoomNameFromPath","WebsocketManager","constructor","isInitialised","activePaths","Set","pageResults","staticQueryResults","errors","init","bind","getSocket","emitPageData","emitStaticQueryData","emitError","connectedClients","server","programDir","websocket","on","s","activePath","handshake","headers","referer","add","send","type","payload","message","errorID","leaveRoom","leave","leftRoom","sockets","adapter","rooms","delete","getDataForPath","why","get","clientsCount","trackCli","siteMeasurements","Array","from","debounce","data","manager","module","exports"],"mappings":"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","sourcesContent":["// @flow\n\nconst path = require(`path`)\nconst { store } = require(`../redux`)\nconst fs = require(`fs`)\nconst pageDataUtil = require(`../utils/page-data`)\nconst normalizePagePath = require(`../utils/normalize-page-path`)\nconst telemetry = require(`gatsby-telemetry`)\nconst url = require(`url`)\nconst { createHash } = require(`crypto`)\n\ntype QueryResult = {\n  id: string,\n  result: object,\n}\n\ntype QueryResultsMap = Map<string, QueryResult>\n\nconst denormalize = path => {\n  if (path === undefined) {\n    return path\n  }\n  if (path === `/`) {\n    return `/`\n  }\n  if (path.charAt(path.length - 1) !== `/`) {\n    return path + `/`\n  }\n  return path\n}\n\n/**\n * Get cached page query result for given page path.\n * @param {string} pagePath Path to a page.\n * @param {string} directory Root directory of current project.\n */\nconst getCachedPageData = async (\n  pagePath: string,\n  directory: string\n): QueryResult => {\n  const { program, pages } = store.getState()\n  const publicDir = path.join(program.directory, `public`)\n  if (pages.has(denormalize(pagePath)) || pages.has(pagePath)) {\n    try {\n      const pageData = await pageDataUtil.read({ publicDir }, pagePath)\n\n      return {\n        result: pageData.result,\n        id: pagePath,\n      }\n    } catch (err) {\n      throw new Error(\n        `Error loading a result for the page query in \"${pagePath}\". Query was not run and no cached result was found.`\n      )\n    }\n  }\n\n  return undefined\n}\n\nconst hashPaths = paths => {\n  if (!paths) {\n    return undefined\n  }\n  return paths.map(path => {\n    if (!path) {\n      return undefined\n    }\n    return createHash(`sha256`)\n      .update(path)\n      .digest(`hex`)\n  })\n}\n\n/**\n * Get cached StaticQuery results for components that Gatsby didn't run query yet.\n * @param {QueryResultsMap} resultsMap Already stored results for queries that don't need to be read from files.\n * @param {string} directory Root directory of current project.\n */\nconst getCachedStaticQueryResults = (\n  resultsMap: QueryResultsMap,\n  directory: string\n): QueryResultsMap => {\n  const cachedStaticQueryResults = new Map()\n  const { staticQueryComponents } = store.getState()\n  staticQueryComponents.forEach(staticQueryComponent => {\n    // Don't read from file if results were already passed from query runner\n    if (resultsMap.has(staticQueryComponent.hash)) return\n    const filePath = path.join(\n      directory,\n      `public`,\n      `static`,\n      `d`,\n      `${staticQueryComponent.hash}.json`\n    )\n    const fileResult = fs.readFileSync(filePath, `utf-8`)\n    if (fileResult === `undefined`) {\n      console.log(\n        `Error loading a result for the StaticQuery in \"${\n          staticQueryComponent.componentPath\n        }\". Query was not run and no cached result was found.`\n      )\n      return\n    }\n    cachedStaticQueryResults.set(staticQueryComponent.hash, {\n      result: JSON.parse(fileResult),\n      id: staticQueryComponent.hash,\n    })\n  })\n  return cachedStaticQueryResults\n}\n\nconst getRoomNameFromPath = (path: string): string => `path-${path}`\n\nclass WebsocketManager {\n  pageResults: QueryResultsMap\n  staticQueryResults: QueryResultsMap\n  errors: Map<string, QueryResult>\n  isInitialised: boolean\n  activePaths: Set<string>\n  programDir: string\n\n  constructor() {\n    this.isInitialised = false\n    this.activePaths = new Set()\n    this.pageResults = new Map()\n    this.staticQueryResults = new Map()\n    this.errors = new Map()\n    // this.websocket\n    // this.programDir\n\n    this.init = this.init.bind(this)\n    this.getSocket = this.getSocket.bind(this)\n    this.emitPageData = this.emitPageData.bind(this)\n    this.emitStaticQueryData = this.emitStaticQueryData.bind(this)\n    this.emitError = this.emitError.bind(this)\n    this.connectedClients = 0\n  }\n\n  init({ server, directory }) {\n    this.programDir = directory\n\n    const cachedStaticQueryResults = getCachedStaticQueryResults(\n      this.staticQueryResults,\n      this.programDir\n    )\n    this.staticQueryResults = new Map([\n      ...this.staticQueryResults,\n      ...cachedStaticQueryResults,\n    ])\n\n    this.websocket = require(`socket.io`)(server)\n\n    this.websocket.on(`connection`, s => {\n      let activePath = null\n      if (\n        s &&\n        s.handshake &&\n        s.handshake.headers &&\n        s.handshake.headers.referer\n      ) {\n        const path = url.parse(s.handshake.headers.referer).path\n        if (path) {\n          activePath = path\n          this.activePaths.add(path)\n        }\n      }\n\n      this.connectedClients += 1\n      // Send already existing static query results\n      this.staticQueryResults.forEach(result => {\n        this.websocket.send({\n          type: `staticQueryResult`,\n          payload: result,\n        })\n      })\n      this.errors.forEach((message, errorID) => {\n        this.websocket.send({\n          type: `overlayError`,\n          payload: {\n            id: errorID,\n            message,\n          },\n        })\n      })\n\n      const leaveRoom = path => {\n        s.leave(getRoomNameFromPath(path))\n        const leftRoom = this.websocket.sockets.adapter.rooms[\n          getRoomNameFromPath(path)\n        ]\n        if (!leftRoom || leftRoom.length === 0) {\n          this.activePaths.delete(path)\n        }\n      }\n\n      const getDataForPath = async path => {\n        if (!this.pageResults.has(path)) {\n          try {\n            const result = await getCachedPageData(path, this.programDir)\n\n            if (!result) {\n              return\n            }\n\n            this.pageResults.set(path, result)\n          } catch (err) {\n            console.log(err.message)\n\n            return\n          }\n        }\n\n        this.websocket.send({\n          type: `pageQueryResult`,\n          why: `getDataForPath`,\n          payload: this.pageResults.get(path),\n        })\n\n        const clientsCount = this.connectedClients\n        if (clientsCount && clientsCount > 0) {\n          telemetry.trackCli(\n            `WEBSOCKET_PAGE_DATA_UPDATE`,\n            {\n              siteMeasurements: {\n                clientsCount,\n                paths: hashPaths(Array.from(this.activePaths)),\n              },\n            },\n            { debounce: true }\n          )\n        }\n      }\n\n      s.on(`getDataForPath`, getDataForPath)\n\n      s.on(`registerPath`, path => {\n        s.join(getRoomNameFromPath(path))\n        activePath = path\n        this.activePaths.add(path)\n      })\n\n      s.on(`disconnect`, s => {\n        leaveRoom(activePath)\n        this.connectedClients -= 1\n      })\n\n      s.on(`unregisterPath`, path => {\n        leaveRoom(path)\n      })\n    })\n\n    this.isInitialised = true\n  }\n\n  getSocket() {\n    return this.isInitialised && this.websocket\n  }\n\n  emitStaticQueryData(data: QueryResult) {\n    this.staticQueryResults.set(data.id, data)\n    if (this.isInitialised) {\n      this.websocket.send({ type: `staticQueryResult`, payload: data })\n      const clientsCount = this.connectedClients\n      if (clientsCount && clientsCount > 0) {\n        telemetry.trackCli(\n          `WEBSOCKET_EMIT_STATIC_PAGE_DATA_UPDATE`,\n          {\n            siteMeasurements: {\n              clientsCount,\n              paths: hashPaths(Array.from(this.activePaths)),\n            },\n          },\n          { debounce: true }\n        )\n      }\n    }\n  }\n\n  emitPageData(data: QueryResult) {\n    data.id = normalizePagePath(data.id)\n    this.pageResults.set(data.id, data)\n    if (this.isInitialised) {\n      this.websocket.send({ type: `pageQueryResult`, payload: data })\n      const clientsCount = this.connectedClients\n      if (clientsCount && clientsCount > 0) {\n        telemetry.trackCli(\n          `WEBSOCKET_EMIT_PAGE_DATA_UPDATE`,\n          {\n            siteMeasurements: {\n              clientsCount,\n              paths: hashPaths(Array.from(this.activePaths)),\n            },\n          },\n          { debounce: true }\n        )\n      }\n    }\n  }\n  emitError(id: string, message?: string) {\n    if (message) {\n      this.errors.set(id, message)\n    } else {\n      this.errors.delete(id)\n    }\n\n    if (this.isInitialised) {\n      this.websocket.send({ type: `overlayError`, payload: { id, message } })\n    }\n  }\n}\n\nconst manager = new WebsocketManager()\n\nmodule.exports = manager\n"],"file":"websocket-manager.js"}