{"version":3,"sources":["../../src/utils/api-node-docs.js"],"names":["exports","resolvableExtensions","createPages","createPagesStatefully","sourceNodes","onCreateNode","onCreatePage","setFieldsOnGraphQLNodeType","createSchemaCustomization","createResolvers","preprocessSource","generateSideEffects","onCreateBabelConfig","onCreateWebpackConfig","onPreInit","onPreBootstrap","onPostBootstrap","onPreBuild","onPostBuild","onPreExtractQueries","onCreateDevServer"],"mappings":";;AAAA;;;;;AAKAA,OAAO,CAACC,oBAAR,GAA+B,IAA/B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuDAD,OAAO,CAACE,WAAR,GAAsB,IAAtB;AAEA;;;;;;;;;;;;;;;AAcAF,OAAO,CAACG,qBAAR,GAAgC,IAAhC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCAH,OAAO,CAACI,WAAR,GAAsB,IAAtB;AAEA;;;;;;;;;;;;;;AAaAJ,OAAO,CAACK,YAAR,GAAuB,IAAvB;AAEA;;;;;;;;;AAQAL,OAAO,CAACM,YAAR,GAAuB,IAAvB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDAN,OAAO,CAACO,0BAAR,GAAqC,IAArC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CAP,OAAO,CAACQ,yBAAR,GAAoC,IAApC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmEAR,OAAO,CAACS,eAAR,GAA0B,IAA1B;AAEA;;;;;AAIAT,OAAO,CAACU,gBAAR,GAA2B,IAA3B;AAEA;;;;;;AAKAV,OAAO,CAACW,mBAAR,GAA8B,IAA9B;AAEA;;;;;;AAKAX,OAAO,CAACY,mBAAR,GAA8B,IAA9B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BAZ,OAAO,CAACa,qBAAR,GAAgC,IAAhC;AAEA;;;;AAGAb,OAAO,CAACc,SAAR,GAAoB,IAApB;AAEA;;;;AAGAd,OAAO,CAACe,cAAR,GAAyB,IAAzB;AAEA;;;;AAGAf,OAAO,CAACgB,eAAR,GAA0B,IAA1B;AAEA;;;;AAGAhB,OAAO,CAACiB,UAAR,GAAqB,IAArB;AAEA;;;;;AAIAjB,OAAO,CAACkB,WAAR,GAAsB,IAAtB;AAEA;;;;;;;AAMAlB,OAAO,CAACmB,mBAAR,GAA8B,IAA9B;AAEA;;;;;;;;;;;;;AAYAnB,OAAO,CAACoB,iBAAR,GAA4B,IAA5B","sourcesContent":["/**\n * Lets plugins implementing support for other compile-to-js add to the list\n * of \"resolvable\" file extensions. Gatsby supports `.js` and `.jsx` by default.\n * @returns {Array<string>} array of extensions\n */\nexports.resolvableExtensions = true\n\n/**\n * Tell plugins to add pages. This extension point is called only after the initial\n * sourcing and transformation of nodes plus creation of the GraphQL schema are\n * complete so you can query your data in order to create pages.\n *\n * See also [the documentation for the action `createPage`](/docs/actions/#createPage).\n * @example\n * const path = require(`path`)\n *\n * exports.createPages = ({ graphql, actions }) => {\n *   const { createPage } = actions\n *   const blogPostTemplate = path.resolve(`src/templates/blog-post.js`)\n *   // Query for markdown nodes to use in creating pages.\n *   // You can query for whatever data you want to create pages for e.g.\n *   // products, portfolio items, landing pages, etc.\n *   // Variables can be added as the second function parameter\n *   return graphql(`\n *     query loadPagesQuery ($limit: Int!) {\n *       allMarkdownRemark(limit: $limit) {\n *         edges {\n *           node {\n *             frontmatter {\n *               slug\n *             }\n *           }\n *         }\n *       }\n *     }\n *   `, { limit: 1000 }).then(result => {\n *     if (result.errors) {\n *       throw result.errors\n *     }\n *\n *     // Create blog post pages.\n *     result.data.allMarkdownRemark.edges.forEach(edge => {\n *       createPage({\n *         // Path for this page â€” required\n *         path: `${edge.node.frontmatter.slug}`,\n *         component: blogPostTemplate,\n *         context: {\n *           // Add optional context data to be inserted\n *           // as props into the page component..\n *           //\n *           // The context data can also be used as\n *           // arguments to the page GraphQL query.\n *           //\n *           // The page \"path\" is always available as a GraphQL\n *           // argument.\n *         },\n *       })\n *     })\n *   })\n * }\n */\n\nexports.createPages = true\n\n/**\n * Like `createPages` but for plugins who want to manage creating and removing\n * pages themselves in response to changes in data *not* managed by Gatsby.\n * Plugins implementing `createPages` will get called regularly to recompute\n * page information as Gatsby's data changes but those implementing\n * `createPagesStatefully` will not.\n *\n * An example of a plugin that uses this extension point is the plugin\n * [gatsby-plugin-page-creator](https://github.com/gatsbyjs/gatsby/tree/master/packages/gatsby-plugin-page-creator)\n * which monitors the `src/pages` directory for the adding and removal of JS\n * pages. As its source of truth, files in the pages directory, is not known by\n * Gatsby, it needs to keep its own state about its world to know when to\n * add and remove pages.\n */\nexports.createPagesStatefully = true\n\n/**\n * Extension point to tell plugins to source nodes. This API is called during\n * the Gatsby bootstrap sequence. Source plugins use this hook to create nodes.\n * This API is called exactly once per plugin (and once for your site's\n * `gatsby-config.js` file). If you define this hook in `gatsby-node.js` it\n * will be called exactly once after all of your source plugins have finished\n * creating nodes.\n *\n * See also the documentation for [`createNode`](/docs/actions/#createNode).\n * @example\n * exports.sourceNodes = ({ actions, createNodeId, createContentDigest }) => {\n *   const { createNode } = actions\n *\n *   // Data can come from anywhere, but for now create it manually\n *   const myData = {\n *     key: 123,\n *     foo: `The foo field of my node`,\n *     bar: `Baz`\n *   }\n *\n *   const nodeContent = JSON.stringify(myData)\n *\n *   const nodeMeta = {\n *     id: createNodeId(`my-data-${myData.key}`),\n *     parent: null,\n *     children: [],\n *     internal: {\n *       type: `MyNodeType`,\n *       mediaType: `text/html`,\n *       content: nodeContent,\n *       contentDigest: createContentDigest(myData)\n *     }\n *   }\n *\n *   const node = Object.assign({}, myData, nodeMeta)\n *   createNode(node)\n * }\n */\nexports.sourceNodes = true\n\n/**\n * Called when a new node is created. Plugins wishing to extend or\n * transform nodes created by other plugins should implement this API.\n *\n * See also the documentation for [`createNode`](/docs/actions/#createNode)\n * and [`createNodeField`](/docs/actions/#createNodeField)\n * @example\n * exports.onCreateNode = ({ node, actions }) => {\n *   const { createNode, createNodeField } = actions\n *   // Transform the new node here and create a new node or\n *   // create a new node field.\n * }\n */\nexports.onCreateNode = true\n\n/**\n * Called when a new page is created. This extension API is useful\n * for programmatically manipulating pages created by other plugins e.g.\n * if you want paths without trailing slashes.\n *\n * See the guide [Creating and Modifying Pages](/docs/creating-and-modifying-pages/)\n * for more on this API.\n */\nexports.onCreatePage = true\n\n/**\n * Called during the creation of the GraphQL schema. Allows plugins\n * to add new fields to the types created from data nodes. It will be called\n * separately for each type.\n *\n * This function should return an object in the shape of\n * [GraphQLFieldConfigMap](https://graphql.org/graphql-js/type/#graphqlobjecttype)\n * which will be appended to fields inferred by Gatsby from data nodes.\n *\n * *Note:* Import GraphQL types from `gatsby/graphql` and don't add the `graphql`\n * package to your project/plugin dependencies to avoid `Schema must\n * contain unique named types but contains multiple types named` errors.\n * `gatsby/graphql` exports all builtin GraphQL types as well as the `GraphQLJSON`\n * type.\n *\n * Many transformer plugins use this to add fields that take arguments.\n *\n * * [`gatsby-transformer-remark`](/packages/gatsby-transformer-remark/)\n * adds an \"excerpt\" field where the user when writing their query can specify\n * how many characters to prune the markdown source to.\n * * [`gatsby-transformer-sharp`](/packages/gatsby-transformer-sharp/) exposes\n * many image transformation options as GraphQL fields.\n *\n * @param {object} $0\n * @param {object} $0.type Object containing `name` and `nodes`\n * @example\n * import { GraphQLString } from \"gatsby/graphql\"\n *\n * exports.setFieldsOnGraphQLNodeType = ({ type }) => {\n *   if (type.name === `File`) {\n *     return {\n *       newField: {\n *         type: GraphQLString,\n *         args: {\n *           myArgument: {\n *             type: GraphQLString,\n *           }\n *         },\n *         resolve: (source, fieldArgs) => {\n *           return `Id of this node is ${source.id}.\n *                   Field was called with argument: ${fieldArgs.myArgument}`\n *         }\n *       }\n *     }\n *   }\n *\n *   // by default return empty object\n *   return {}\n * }\n */\nexports.setFieldsOnGraphQLNodeType = true\n\n/**\n * Customize Gatsby's GraphQL schema by creating type definitions, field\n * extensions or adding third-party schemas.\n *\n * The [`createTypes`](/docs/actions/#createTypes),\n * [`createFieldExtension`](/docs/actions/#createFieldExtension) and\n * [`addThirdPartySchema`](/docs/actions/#addThirdPartySchema) actions\n * are only available in this API. For details on their usage please refer to\n * the actions documentation.\n *\n * This API runs immediately before schema generation. For modifications of the\n * generated schema, e.g. to customize added third-party types, use the\n * [`createResolvers`](/docs/node-apis/#createResolvers) API.\n *\n * @gatsbyVersion 2.12.0\n * @param {object} $0\n * @param {object} $0.actions\n * @param {object} $0.actions.createTypes\n * @param {object} $0.actions.createFieldExtension\n * @param {object} $0.actions.addThirdPartySchema\n * @example\n * exports.createSchemaCustomization = ({ actions }) => {\n *   const { createTypes, createFieldExtension } = actions\n *\n *   createFieldExtension({\n *     name: 'shout',\n *     extend: () => ({\n *       resolve(source, args, context, info) {\n *         return String(source[info.fieldName]).toUpperCase()\n *       }\n *     })\n *   })\n *\n *   const typeDefs = `\n *     type MarkdownRemark implements Node @dontInfer {\n *       frontmatter: Frontmatter\n *     }\n *     type Frontmatter {\n *       title: String!\n *       tagline: String @shout\n *       date: Date @dateformat\n *       image: File @fileByRelativePath\n *     }\n *   `\n *   createTypes(typeDefs)\n * }\n */\nexports.createSchemaCustomization = true\n\n/**\n * Add custom field resolvers to the GraphQL schema.\n *\n * Allows adding new fields to types by providing field configs, or adding resolver\n * functions to existing fields.\n *\n * Things to note:\n * * Overriding field types is disallowed, instead use the `createTypes`\n *   action. In case of types added from third-party schemas, where this is not\n *   possible, overriding field types is allowed.\n * * New fields will not be available on `filter` and `sort` input types. Extend\n *   types defined with `createTypes` if you need this.\n * * In field configs, types can be referenced as strings.\n * * When extending a field with an existing field resolver, the original\n *   resolver function is available from `info.originalResolver`.\n * * The `createResolvers` API is called as the last step in schema generation.\n *   Thus, an intermediate schema is made available on the `intermediateSchema` property.\n *   In resolver functions themselves, it is recommended to access the final\n *   built schema from `info.schema`.\n * * Gatsby's data layer, including all internal query capabilities, is\n *   exposed on [`context.nodeModel`](/docs/node-model/). The node store can be\n *   queried directly with `getAllNodes`, `getNodeById` and `getNodesByIds`,\n *   while more advanced queries can be composed with `runQuery`. Note that\n *   `runQuery` will call field resolvers before querying, so e.g. foreign-key\n *   fields will be expanded to full nodes. The other methods on `nodeModel`\n *   don't do this.\n * * It is possible to add fields to the root `Query` type.\n * * When using the first resolver argument (`source` in the example below,\n *   often also called `parent` or `root`), take care of the fact that field\n *   resolvers can be called more than once in a query, e.g. when the field is\n *   present both in the input filter and in the selection set. This means that\n *   foreign-key fields on `source` can be either resolved or not-resolved.\n *\n * For fuller examples, see [`using-type-definitions`](https://github.com/gatsbyjs/gatsby/tree/master/examples/using-type-definitions).\n *\n * @gatsbyVersion 2.2.0\n * @param {object} $0\n * @param {GraphQLSchema} $0.intermediateSchema Current GraphQL schema\n * @param {function} $0.createResolvers Add custom resolvers to GraphQL field configs\n * @param {object} $1\n * @param {object} $1.resolvers Resolvers from plugin options in `gatsby-config.js`.\n * @example\n * exports.createResolvers = ({ createResolvers }) => {\n *   const resolvers = {\n *     Author: {\n *       fullName: {\n *         resolve: (source, args, context, info) => {\n *           return source.firstName + source.lastName\n *         }\n *       },\n *     },\n *     Query: {\n *       allRecentPosts: {\n *         type: [`BlogPost`],\n *         resolve: (source, args, context, info) => {\n *           const posts = context.nodeModel.getAllNodes({ type: `BlogPost` })\n *           const recentPosts = posts.filter(\n *             post => post.publishedAt > Date.UTC(2018, 0, 1)\n *           )\n *           return recentPosts\n *         }\n *       }\n *     }\n *   }\n *   createResolvers(resolvers)\n * }\n */\nexports.createResolvers = true\n\n/**\n * Ask compile-to-js plugins to process source to JavaScript so the query\n * runner can extract out GraphQL queries for running.\n */\nexports.preprocessSource = true\n\n/**\n * Tell plugins with expensive \"side effects\" from queries to start running\n * those now. This is a soon-to-be-replaced API only currently in use by\n * `gatsby-plugin-sharp`.\n */\nexports.generateSideEffects = true\n\n/**\n * Let plugins extend/mutate the site's Babel configuration.\n * This API will change before 2.0 as it needs still to be converted to use\n * Redux actions.\n */\nexports.onCreateBabelConfig = true\n\n/**\n * Let plugins extend/mutate the site's webpack configuration.\n *\n * See also the documentation for [`setWebpackConfig`](/docs/actions/#setWebpackConfig).\n *\n * @param {object} $0\n * @param {string} $0.stage The current build stage. One of 'develop', 'develop-html',\n * 'build-javascript', or 'build-html'\n * @param {function} $0.getConfig Returns the current webpack config\n * @param {object} $0.rules A set of preconfigured webpack config rules\n * @param {object} $0.loaders A set of preconfigured webpack config loaders\n * @param {object} $0.plugins A set of preconfigured webpack config plugins\n * @param {object} $0.actions\n * @example\n * exports.onCreateWebpackConfig = ({\n *  stage, getConfig, rules, loaders, actions\n * }) => {\n *   actions.setWebpackConfig({\n *     module: {\n *       rules: [\n *         {\n *           test: 'my-css',\n *           use: [loaders.style(), loaders.css()]\n *         },\n *       ],\n *     },\n *   });\n * }\n */\nexports.onCreateWebpackConfig = true\n\n/**\n * The first API called during Gatsby execution, runs as soon as plugins are loaded, before cache initialization and bootstrap preparation.\n */\nexports.onPreInit = true\n\n/**\n * Called once Gatsby has initialized itself and is ready to bootstrap your site.\n */\nexports.onPreBootstrap = true\n\n/**\n * Called at the end of the bootstrap process after all other extension APIs have been called.\n */\nexports.onPostBootstrap = true\n\n/**\n * The first extension point called during the build process. Called after the bootstrap has completed but before the build steps start.\n */\nexports.onPreBuild = true\n\n/**\n * The last extension point called after all other parts of the build process\n * are complete.\n */\nexports.onPostBuild = true\n\n/**\n * Run before GraphQL queries/fragments are extracted from JavaScript files. Useful for plugins\n * to add more JavaScript files with queries/fragments e.g. from node_modules.\n *\n * See gatsby-transformer-sharp and gatsby-source-contentful for examples.\n */\nexports.onPreExtractQueries = true\n\n/**\n * Run when gatsby develop server is started, its useful to add proxy and middleware\n * to the dev server app\n * @param {object} $0\n * @param {Express} $0.app The [Express app](https://expressjs.com/en/4x/api.html#app) used to run the dev server\n * @example\n * exports.onCreateDevServer = ({ app }) => {\n *   app.get('/hello', function (req, res) {\n *     res.send('hello world')\n *   })\n * }\n */\nexports.onCreateDevServer = true\n"],"file":"api-node-docs.js"}