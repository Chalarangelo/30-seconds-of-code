{"version":3,"sources":["../../src/query/error-parser.js"],"names":["errorParser","message","filePath","location","handlers","regex","cb","match","id","context","sourceMessage","fieldName","typeName","structured","matched"],"mappings":";;;;;AAAA,MAAMA,WAAW,GAAG,CAAC;AAAEC,EAAAA,OAAF;AAAWC,EAAAA,QAAX;AAAqBC,EAAAA;AAArB,CAAD,KAAqC;AACvD;AACA;AACA,QAAMC,QAAQ,GAAG,CACf;AACEC,IAAAA,KAAK,EAAE,4EADT;AAEEC,IAAAA,EAAE,EAAEC,KAAK,IAAI;AACX,aAAO;AACLC,QAAAA,EAAE,EAAG,OADA;AAELC,QAAAA,OAAO,EAAE;AACPC,UAAAA,aAAa,EAAEH,KAAK,CAAC,CAAD,CADb;AAEPI,UAAAA,SAAS,EAAEJ,KAAK,CAAC,CAAD,CAFT;AAGPK,UAAAA,QAAQ,EAAEL,KAAK,CAAC,CAAD;AAHR;AAFJ,OAAP;AAQD;AAXH,GADe,EAcf;AACEF,IAAAA,KAAK,EAAE,qCADT;AAEEC,IAAAA,EAAE,EAAEC,KAAK,IAAI;AACX,aAAO;AACLC,QAAAA,EAAE,EAAG,OADA;AAELC,QAAAA,OAAO,EAAE;AAAER,UAAAA,OAAO,EAAEM,KAAK,CAAC,CAAD;AAAhB;AAFJ,OAAP;AAID;AAPH,GAde,EAuBf;AACA;AACEF,IAAAA,KAAK,EAAE,WADT;AAEEC,IAAAA,EAAE,EAAEC,KAAK,IAAI;AACX,aAAO;AACLC,QAAAA,EAAE,EAAG,OADA;AAELC,QAAAA,OAAO,EAAE;AAAEC,UAAAA,aAAa,EAAEH,KAAK,CAAC,CAAD;AAAtB;AAFJ,OAAP;AAID;AAPH,GAxBe,CAAjB;AAmCA,MAAIM,UAAJ;;AAEA,qBAA4BT,QAA5B,EAAsC;AAAA,UAA3B;AAAEC,MAAAA,KAAF;AAASC,MAAAA;AAAT,KAA2B;AACpC,QAAIQ,OAAO,GAAGb,OAAO,CAACM,KAAR,CAAcF,KAAd,CAAd;;AACA,QAAIS,OAAJ,EAAa;AACXD,MAAAA,UAAU;AACRX,QAAAA,QADQ;AAERC,QAAAA;AAFQ,SAGLG,EAAE,CAACQ,OAAD,CAHG,CAAV;AAKA;AACD;AACF;;AAED,SAAOD,UAAP;AACD,CArDD;;eAuDeb,W","sourcesContent":["const errorParser = ({ message, filePath, location }) => {\n  // Handle specific errors from Relay. A list of regexes to match certain\n  // errors to specific callbacks\n  const handlers = [\n    {\n      regex: /Field \"(.+)\" must not have a selection since type \"(.+)\" has no subfields/m,\n      cb: match => {\n        return {\n          id: `85909`,\n          context: {\n            sourceMessage: match[0],\n            fieldName: match[1],\n            typeName: match[2],\n          },\n        }\n      },\n    },\n    {\n      regex: /Encountered\\s\\d\\serror.*:\\n\\s*(.*)/m,\n      cb: match => {\n        return {\n          id: `85907`,\n          context: { message: match[1] },\n        }\n      },\n    },\n    // Match anything with a generic catch-all error handler\n    {\n      regex: /[\\s\\S]*/gm,\n      cb: match => {\n        return {\n          id: `85901`,\n          context: { sourceMessage: match[0] },\n        }\n      },\n    },\n  ]\n\n  let structured\n\n  for (const { regex, cb } of handlers) {\n    let matched = message.match(regex)\n    if (matched) {\n      structured = {\n        filePath,\n        location,\n        ...cb(matched),\n      }\n      break\n    }\n  }\n\n  return structured\n}\n\nexport default errorParser\n"],"file":"error-parser.js"}