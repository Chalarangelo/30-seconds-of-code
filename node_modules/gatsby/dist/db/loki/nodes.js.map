{"version":3,"sources":["../../../src/db/loki/nodes.js"],"names":["_","require","invariant","getDb","colls","makeTypeCollName","type","createNodeTypeCollection","collName","nodeTypesColl","getCollection","nodeTypes","name","insert","options","unique","indices","disableMeta","coll","addCollection","getTypeCollName","nodeTypeInfo","by","undefined","getNodeTypeCollection","typeCollName","deleteNodeTypeCollections","force","find","nodeType","count","removeCollection","remove","deleteAll","db","nodeMeta","clear","getNode","id","nodeMetaColl","typeColl","getNodesByType","typeName","data","getNodes","getTypes","flatMap","map","getNodeAndSavePathDependency","path","createPageDependency","node","nodeId","hasNodeChanged","digest","internal","contentDigest","createNode","oldNode","deleteNode","nodeTypeColl","updateNode","update","findAndRemove","deleteNodes","nodes","reducer","state","Map","action","payload","module","exports"],"mappings":";;AAAA,MAAMA,CAAC,GAAGC,OAAO,CAAE,QAAF,CAAjB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAE,WAAF,CAAzB;;AACA,MAAM;AAAEE,EAAAA,KAAF;AAASC,EAAAA;AAAT,IAAmBH,OAAO,CAAE,SAAF,CAAhC,C,CAEA;AACA;AACA;;;AAEA,SAASI,gBAAT,CAA0BC,IAA1B,EAAgC;AAC9B,SAAQ,mBAAkBA,IAAK,EAA/B;AACD;AAED;;;;;;;AAKA,SAASC,wBAAT,CAAkCD,IAAlC,EAAwC;AACtC,QAAME,QAAQ,GAAGH,gBAAgB,CAACC,IAAD,CAAjC;AACA,QAAMG,aAAa,GAAGN,KAAK,GAAGO,aAAR,CAAsBN,KAAK,CAACO,SAAN,CAAgBC,IAAtC,CAAtB;AACAV,EAAAA,SAAS,CAACO,aAAD,EAAiB,cAAaL,KAAK,CAACO,SAAN,CAAgBC,IAAK,eAAnD,CAAT;AACAH,EAAAA,aAAa,CAACI,MAAd,CAAqB;AAAEP,IAAAA,IAAF;AAAQE,IAAAA;AAAR,GAArB,EAJsC,CAKtC;AACA;AACA;;AACA,QAAMM,OAAO,GAAG;AACdC,IAAAA,MAAM,EAAE,CAAE,IAAF,CADM;AAEdC,IAAAA,OAAO,EAAE,CAAE,IAAF,CAFK;AAGdC,IAAAA,WAAW,EAAE;AAHC,GAAhB;AAKA,QAAMC,IAAI,GAAGf,KAAK,GAAGgB,aAAR,CAAsBX,QAAtB,EAAgCM,OAAhC,CAAb;AACA,SAAOI,IAAP;AACD;AAED;;;;;;AAIA,SAASE,eAAT,CAAyBd,IAAzB,EAA+B;AAC7B,QAAMG,aAAa,GAAGN,KAAK,GAAGO,aAAR,CAAsBN,KAAK,CAACO,SAAN,CAAgBC,IAAtC,CAAtB;AACAV,EAAAA,SAAS,CAACO,aAAD,EAAiB,cAAaL,KAAK,CAACO,SAAN,CAAgBC,IAAK,eAAnD,CAAT;AACA,MAAIS,YAAY,GAAGZ,aAAa,CAACa,EAAd,CAAkB,MAAlB,EAAyBhB,IAAzB,CAAnB;AACA,SAAOe,YAAY,GAAGA,YAAY,CAACb,QAAhB,GAA2Be,SAA9C;AACD;AAED;;;;;;AAIA,SAASC,qBAAT,CAA+BlB,IAA/B,EAAqC;AACnC,QAAMmB,YAAY,GAAGL,eAAe,CAACd,IAAD,CAApC;AACA,MAAIY,IAAJ;;AACA,MAAIO,YAAJ,EAAkB;AAChBP,IAAAA,IAAI,GAAGf,KAAK,GAAGO,aAAR,CAAsBe,YAAtB,CAAP;AACAvB,IAAAA,SAAS,CACPgB,IADO,EAEN,SAAQZ,IAAK,iDAAgDmB,YAAa,GAFpE,CAAT;AAIA,WAAOP,IAAP;AACD,GAPD,MAOO;AACL,WAAOK,SAAP;AACD;AACF;AAED;;;;;;;AAKA,SAASG,yBAAT,CAAmCC,KAAK,GAAG,KAA3C,EAAkD;AAChD,QAAMlB,aAAa,GAAGN,KAAK,GAAGO,aAAR,CAAsBN,KAAK,CAACO,SAAN,CAAgBC,IAAtC,CAAtB,CADgD,CAEhD;;AACA,QAAMD,SAAS,GAAGF,aAAa,CAACmB,IAAd,EAAlB;;AACA,OAAK,MAAMC,QAAX,IAAuBlB,SAAvB,EAAkC;AAChC,QAAIO,IAAI,GAAGf,KAAK,GAAGO,aAAR,CAAsBmB,QAAQ,CAACrB,QAA/B,CAAX;;AACA,QAAIU,IAAI,CAACY,KAAL,OAAiB,CAAjB,IAAsBH,KAA1B,EAAiC;AAC/BxB,MAAAA,KAAK,GAAG4B,gBAAR,CAAyBb,IAAI,CAACN,IAA9B;AACAH,MAAAA,aAAa,CAACuB,MAAd,CAAqBH,QAArB;AACD;AACF;AACF;AAED;;;;;;;AAKA,SAASI,SAAT,GAAqB;AACnB,QAAMC,EAAE,GAAG/B,KAAK,EAAhB;;AACA,MAAI+B,EAAJ,EAAQ;AACNR,IAAAA,yBAAyB,CAAC,IAAD,CAAzB;AACAQ,IAAAA,EAAE,CAACxB,aAAH,CAAiBN,KAAK,CAAC+B,QAAN,CAAevB,IAAhC,EAAsCwB,KAAtC;AACD;AACF,C,CAED;AACA;AACA;;AAEA;;;;;AAGA,SAASC,OAAT,CAAiBC,EAAjB,EAAqB;AACnB,MAAI,CAACA,EAAL,EAAS;AACP,WAAO,IAAP;AACD,GAHkB,CAInB;;;AACA,QAAMC,YAAY,GAAGpC,KAAK,GAAGO,aAAR,CAAsBN,KAAK,CAAC+B,QAAN,CAAevB,IAArC,CAArB;AACAV,EAAAA,SAAS,CAACqC,YAAD,EAAgB,kCAAhB,CAAT;AACA,QAAMJ,QAAQ,GAAGI,YAAY,CAACjB,EAAb,CAAiB,IAAjB,EAAsBgB,EAAtB,CAAjB;;AACA,MAAIH,QAAJ,EAAc;AACZ;AACA;AACA,UAAM;AAAEV,MAAAA;AAAF,QAAmBU,QAAzB;AACA,UAAMK,QAAQ,GAAGrC,KAAK,GAAGO,aAAR,CAAsBe,YAAtB,CAAjB;AACAvB,IAAAA,SAAS,CACPsC,QADO,EAEN,mBAAkBf,YAAa,2CAFzB,CAAT;AAIA,WAAOe,QAAQ,CAAClB,EAAT,CAAa,IAAb,EAAkBgB,EAAlB,CAAP;AACD,GAVD,MAUO;AACL,WAAOf,SAAP;AACD;AACF;AAED;;;;;;;AAKA,SAASkB,cAAT,CAAwBC,QAAxB,EAAkC;AAChCxC,EAAAA,SAAS,CAACwC,QAAD,EAAY,kBAAZ,CAAT;AACA,QAAMlC,QAAQ,GAAGY,eAAe,CAACsB,QAAD,CAAhC;AACA,QAAMxB,IAAI,GAAGf,KAAK,GAAGO,aAAR,CAAsBF,QAAtB,CAAb;AACA,MAAI,CAACU,IAAL,EAAW,OAAO,EAAP;AACX,SAAOA,IAAI,CAACyB,IAAZ;AACD;AAED;;;;;;AAIA,SAASC,QAAT,GAAoB;AAClB,QAAMjC,SAAS,GAAGkC,QAAQ,EAA1B;AACA,SAAO7C,CAAC,CAAC8C,OAAF,CAAUnC,SAAV,EAAqBkB,QAAQ,IAAIY,cAAc,CAACZ,QAAD,CAA/C,CAAP;AACD;AAED;;;;;AAGA,SAASgB,QAAT,GAAoB;AAClB,QAAMlC,SAAS,GAAGR,KAAK,GAAGO,aAAR,CAAsBN,KAAK,CAACO,SAAN,CAAgBC,IAAtC,EAA4C+B,IAA9D;AACA,SAAOhC,SAAS,CAACoC,GAAV,CAAclB,QAAQ,IAAIA,QAAQ,CAACvB,IAAnC,CAAP;AACD;AAED;;;;;;;;;;;AASA,SAAS0C,4BAAT,CAAsCV,EAAtC,EAA0CW,IAA1C,EAAgD;AAC9C/C,EAAAA,SAAS,CAACoC,EAAD,EAAM,YAAN,CAAT;AACApC,EAAAA,SAAS,CAACoC,EAAD,EAAM,cAAN,CAAT;;AACA,QAAMY,oBAAoB,GAAGjD,OAAO,CAAE,yCAAF,CAApC;;AACA,QAAMkD,IAAI,GAAGd,OAAO,CAACC,EAAD,CAApB;AACAY,EAAAA,oBAAoB,CAAC;AAAED,IAAAA,IAAF;AAAQG,IAAAA,MAAM,EAAEd;AAAhB,GAAD,CAApB;AACA,SAAOa,IAAP;AACD;AAED;;;;;;;;;;AAQA,SAASE,cAAT,CAAwBf,EAAxB,EAA4BgB,MAA5B,EAAoC;AAClC,QAAMH,IAAI,GAAGd,OAAO,CAACC,EAAD,CAApB;;AACA,MAAI,CAACa,IAAL,EAAW;AACT,WAAO,IAAP;AACD,GAFD,MAEO;AACL,WAAOA,IAAI,CAACI,QAAL,CAAcC,aAAd,KAAgCF,MAAvC;AACD;AACF,C,CAED;AACA;AACA;;AAEA;;;;;;;;;AAOA,SAASG,UAAT,CAAoBN,IAApB,EAA0BO,OAA1B,EAAmC;AACjCxD,EAAAA,SAAS,CAACiD,IAAI,CAACI,QAAN,EAAiB,8BAAjB,CAAT;AACArD,EAAAA,SAAS,CAACiD,IAAI,CAACI,QAAL,CAAcjD,IAAf,EAAsB,mCAAtB,CAAT;AACAJ,EAAAA,SAAS,CAACiD,IAAI,CAACb,EAAN,EAAW,wBAAX,CAAT;AAEA,QAAMhC,IAAI,GAAG6C,IAAI,CAACI,QAAL,CAAcjD,IAA3B,CALiC,CAOjC;AACA;;AACA,MAAIoD,OAAJ,EAAa;AACXC,IAAAA,UAAU,CAACD,OAAD,CAAV;AACD;;AAED,MAAIE,YAAY,GAAGpC,qBAAqB,CAAClB,IAAD,CAAxC;;AACA,MAAI,CAACsD,YAAL,EAAmB;AACjBA,IAAAA,YAAY,GAAGrD,wBAAwB,CAACD,IAAD,CAAvC;AACD;;AAED,QAAMiC,YAAY,GAAGpC,KAAK,GAAGO,aAAR,CAAsBN,KAAK,CAAC+B,QAAN,CAAevB,IAArC,CAArB;AACAV,EAAAA,SAAS,CAACqC,YAAD,EAAgB,cAAanC,KAAK,CAAC+B,QAAN,CAAevB,IAAK,eAAjD,CAAT;AACA2B,EAAAA,YAAY,CAAC1B,MAAb,CAAoB;AAAEyB,IAAAA,EAAE,EAAEa,IAAI,CAACb,EAAX;AAAeb,IAAAA,YAAY,EAAEmC,YAAY,CAAChD;AAA1C,GAApB,EApBiC,CAqBjC;AACA;AACA;;AACA,SAAOgD,YAAY,CAAC/C,MAAb,CAAoBsC,IAApB,CAAP;AACD;AAED;;;;;;;;;;AAQA,SAASU,UAAT,CAAoBV,IAApB,EAA0B;AACxBjD,EAAAA,SAAS,CAACiD,IAAI,CAACI,QAAN,EAAiB,8BAAjB,CAAT;AACArD,EAAAA,SAAS,CAACiD,IAAI,CAACI,QAAL,CAAcjD,IAAf,EAAsB,mCAAtB,CAAT;AACAJ,EAAAA,SAAS,CAACiD,IAAI,CAACb,EAAN,EAAW,wBAAX,CAAT;AAEA,QAAMhC,IAAI,GAAG6C,IAAI,CAACI,QAAL,CAAcjD,IAA3B;AAEA,MAAIY,IAAI,GAAGM,qBAAqB,CAAClB,IAAD,CAAhC;AACAJ,EAAAA,SAAS,CAACgB,IAAD,EAAQ,GAAEZ,IAAK,kDAAf,CAAT;AACAY,EAAAA,IAAI,CAAC4C,MAAL,CAAYX,IAAZ;AACD;AAED;;;;;;;;;;AAQA,SAASQ,UAAT,CAAoBR,IAApB,EAA0B;AACxBjD,EAAAA,SAAS,CAACiD,IAAI,CAACI,QAAN,EAAiB,8BAAjB,CAAT;AACArD,EAAAA,SAAS,CAACiD,IAAI,CAACI,QAAL,CAAcjD,IAAf,EAAsB,mCAAtB,CAAT;AACAJ,EAAAA,SAAS,CAACiD,IAAI,CAACb,EAAN,EAAW,wBAAX,CAAT;AAEA,QAAMhC,IAAI,GAAG6C,IAAI,CAACI,QAAL,CAAcjD,IAA3B;AAEA,MAAIsD,YAAY,GAAGpC,qBAAqB,CAAClB,IAAD,CAAxC;;AACA,MAAI,CAACsD,YAAL,EAAmB;AACjB1D,IAAAA,SAAS,CACP0D,YADO,EAEN,GAAEtD,IAAK,kDAFD,CAAT;AAID;;AAED,MAAIsD,YAAY,CAACtC,EAAb,CAAiB,IAAjB,EAAsB6B,IAAI,CAACb,EAA3B,CAAJ,EAAoC;AAClC,UAAMC,YAAY,GAAGpC,KAAK,GAAGO,aAAR,CAAsBN,KAAK,CAAC+B,QAAN,CAAevB,IAArC,CAArB;AACAV,IAAAA,SAAS,CAACqC,YAAD,EAAgB,cAAanC,KAAK,CAAC+B,QAAN,CAAevB,IAAK,eAAjD,CAAT;AACA2B,IAAAA,YAAY,CAACwB,aAAb,CAA2B;AAAEzB,MAAAA,EAAE,EAAEa,IAAI,CAACb;AAAX,KAA3B,EAHkC,CAIlC;AACA;AACA;;AACAsB,IAAAA,YAAY,CAAC5B,MAAb,CAAoBmB,IAApB;AACD,GAvBuB,CAwBxB;;AACD;AAED;;;;;AAGA,SAASa,WAAT,CAAqBC,KAArB,EAA4B;AAC1B,OAAK,MAAMd,IAAX,IAAmBc,KAAnB,EAA0B;AACxBN,IAAAA,UAAU,CAACR,IAAD,CAAV;AACD;AACF,C,CAED;AACA;AACA;;;AAEA,SAASe,OAAT,CAAiBC,KAAK,GAAG,IAAIC,GAAJ,EAAzB,EAAoCC,MAApC,EAA4C;AAC1C,UAAQA,MAAM,CAAC/D,IAAf;AACE,SAAM,cAAN;AACE2B,MAAAA,SAAS;AACT,aAAO,IAAP;;AAEF,SAAM,aAAN;AAAoB;AAClBwB,QAAAA,UAAU,CAACY,MAAM,CAACC,OAAR,EAAiBD,MAAM,CAACX,OAAxB,CAAV;AACA,eAAO,IAAP;AACD;;AAED,SAAM,mBAAN;AACA,SAAM,+BAAN;AACEG,MAAAA,UAAU,CAACQ,MAAM,CAACC,OAAR,CAAV;AACA,aAAO,IAAP;;AAEF,SAAM,aAAN;AAAoB;AAClB,YAAID,MAAM,CAACC,OAAX,EAAoB;AAClBX,UAAAA,UAAU,CAACU,MAAM,CAACC,OAAR,CAAV;AACD;;AACD,eAAO,IAAP;AACD;;AAED,SAAM,cAAN;AAAqB;AACnBN,QAAAA,WAAW,CAACK,MAAM,CAACC,OAAR,CAAX;AACA,eAAO,IAAP;AACD;;AAED;AACE,aAAO,IAAP;AA5BJ;AA8BD,C,CAED;AACA;AACA;;;AAEAC,MAAM,CAACC,OAAP,GAAiB;AACfhD,EAAAA,qBADe;AAGfoB,EAAAA,QAHe;AAIfP,EAAAA,OAJe;AAKfI,EAAAA,cALe;AAMfI,EAAAA,QANe;AAOfQ,EAAAA,cAPe;AAQfL,EAAAA,4BARe;AAUfS,EAAAA,UAVe;AAWfI,EAAAA,UAXe;AAYfF,EAAAA,UAZe;AAcfjC,EAAAA,yBAde;AAefO,EAAAA,SAfe;AAiBfiC,EAAAA;AAjBe,CAAjB","sourcesContent":["const _ = require(`lodash`)\nconst invariant = require(`invariant`)\nconst { getDb, colls } = require(`./index`)\n\n/////////////////////////////////////////////////////////////////////\n// Node collection metadata\n/////////////////////////////////////////////////////////////////////\n\nfunction makeTypeCollName(type) {\n  return `gatsby:nodeType:${type}`\n}\n\n/**\n * Creates a collection that will contain nodes of a certain type. The\n * name of the collection for type `MyType` will be something like\n * `gatsby:nodeType:MyType` (see `makeTypeCollName`)\n */\nfunction createNodeTypeCollection(type) {\n  const collName = makeTypeCollName(type)\n  const nodeTypesColl = getDb().getCollection(colls.nodeTypes.name)\n  invariant(nodeTypesColl, `Collection ${colls.nodeTypes.name} should exist`)\n  nodeTypesColl.insert({ type, collName })\n  // TODO what if `addCollection` fails? We will have inserted into\n  // nodeTypesColl but no collection will exist. Need to make this\n  // into a transaction\n  const options = {\n    unique: [`id`],\n    indices: [`id`],\n    disableMeta: true,\n  }\n  const coll = getDb().addCollection(collName, options)\n  return coll\n}\n\n/**\n * Returns the name of the collection that contains nodes of the\n * specified type, where type is the node's `node.internal.type`\n */\nfunction getTypeCollName(type) {\n  const nodeTypesColl = getDb().getCollection(colls.nodeTypes.name)\n  invariant(nodeTypesColl, `Collection ${colls.nodeTypes.name} should exist`)\n  let nodeTypeInfo = nodeTypesColl.by(`type`, type)\n  return nodeTypeInfo ? nodeTypeInfo.collName : undefined\n}\n\n/**\n * Returns a reference to the collection that contains nodes of the\n * specified type, where type is the node's `node.internal.type`\n */\nfunction getNodeTypeCollection(type) {\n  const typeCollName = getTypeCollName(type)\n  let coll\n  if (typeCollName) {\n    coll = getDb().getCollection(typeCollName)\n    invariant(\n      coll,\n      `Type [${type}] Collection doesn't exist for nodeTypeInfo: [${typeCollName}]`\n    )\n    return coll\n  } else {\n    return undefined\n  }\n}\n\n/**\n * Deletes all empty node type collections, unless `force` is true, in\n * which case it deletes the collections even if they have nodes in\n * them\n */\nfunction deleteNodeTypeCollections(force = false) {\n  const nodeTypesColl = getDb().getCollection(colls.nodeTypes.name)\n  // find() returns all objects in collection\n  const nodeTypes = nodeTypesColl.find()\n  for (const nodeType of nodeTypes) {\n    let coll = getDb().getCollection(nodeType.collName)\n    if (coll.count() === 0 || force) {\n      getDb().removeCollection(coll.name)\n      nodeTypesColl.remove(nodeType)\n    }\n  }\n}\n\n/**\n * Deletes all nodes from all the node type collections, including the\n * id -> type metadata. There will be no nodes related data in loki\n * after this is called\n */\nfunction deleteAll() {\n  const db = getDb()\n  if (db) {\n    deleteNodeTypeCollections(true)\n    db.getCollection(colls.nodeMeta.name).clear()\n  }\n}\n\n/////////////////////////////////////////////////////////////////////\n// Queries\n/////////////////////////////////////////////////////////////////////\n\n/**\n * Returns the node with `id` == id, or null if not found\n */\nfunction getNode(id) {\n  if (!id) {\n    return null\n  }\n  // First, find out which collection the node is in\n  const nodeMetaColl = getDb().getCollection(colls.nodeMeta.name)\n  invariant(nodeMetaColl, `nodeMeta collection should exist`)\n  const nodeMeta = nodeMetaColl.by(`id`, id)\n  if (nodeMeta) {\n    // Now get the collection and query it by the `id` field, which\n    // has an index on it\n    const { typeCollName } = nodeMeta\n    const typeColl = getDb().getCollection(typeCollName)\n    invariant(\n      typeColl,\n      `type collection ${typeCollName} referenced by nodeMeta but doesn't exist`\n    )\n    return typeColl.by(`id`, id)\n  } else {\n    return undefined\n  }\n}\n\n/**\n * Returns all nodes of a type (where `typeName ==\n * node.internal.type`). This is an O(1) operation since nodes are\n * already stored in separate collections by type\n */\nfunction getNodesByType(typeName) {\n  invariant(typeName, `typeName is null`)\n  const collName = getTypeCollName(typeName)\n  const coll = getDb().getCollection(collName)\n  if (!coll) return []\n  return coll.data\n}\n\n/**\n * Returns the collection of all nodes. This should be deprecated and\n * `getNodesByType` should be used instead. Or at least where possible\n */\nfunction getNodes() {\n  const nodeTypes = getTypes()\n  return _.flatMap(nodeTypes, nodeType => getNodesByType(nodeType))\n}\n\n/**\n * Returns the unique collection of all node types\n */\nfunction getTypes() {\n  const nodeTypes = getDb().getCollection(colls.nodeTypes.name).data\n  return nodeTypes.map(nodeType => nodeType.type)\n}\n\n/**\n * Looks up the node by id, records a dependency between the node and\n * the path, and then returns the node\n *\n * @param {string} id node id to lookup\n * @param {string} path the page path to record a node dependency\n * against\n * @returns {Object} node or undefined if not found\n */\nfunction getNodeAndSavePathDependency(id, path) {\n  invariant(id, `id is null`)\n  invariant(id, `path is null`)\n  const createPageDependency = require(`../../redux/actions/add-page-dependency`)\n  const node = getNode(id)\n  createPageDependency({ path, nodeId: id })\n  return node\n}\n\n/**\n * Determine if node has changed (by comparing its\n * `internal.contentDigest`\n *\n * @param {string} id\n * @param {string} digest\n * @returns {boolean}\n */\nfunction hasNodeChanged(id, digest) {\n  const node = getNode(id)\n  if (!node) {\n    return true\n  } else {\n    return node.internal.contentDigest !== digest\n  }\n}\n\n/////////////////////////////////////////////////////////////////////\n// Create/Update/Delete\n/////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a node in the DB. Will create a collection for the node\n * type if one hasn't been created yet\n *\n * @param {Object} node The node to add. Must have an `id` and\n * `internal.type`\n */\nfunction createNode(node, oldNode) {\n  invariant(node.internal, `node has no \"internal\" field`)\n  invariant(node.internal.type, `node has no \"internal.type\" field`)\n  invariant(node.id, `node has no \"id\" field`)\n\n  const type = node.internal.type\n\n  // Loki doesn't provide \"upsert\", so if the node already exists, we\n  // delete and then create it\n  if (oldNode) {\n    deleteNode(oldNode)\n  }\n\n  let nodeTypeColl = getNodeTypeCollection(type)\n  if (!nodeTypeColl) {\n    nodeTypeColl = createNodeTypeCollection(type)\n  }\n\n  const nodeMetaColl = getDb().getCollection(colls.nodeMeta.name)\n  invariant(nodeMetaColl, `Collection ${colls.nodeMeta.name} should exist`)\n  nodeMetaColl.insert({ id: node.id, typeCollName: nodeTypeColl.name })\n  // TODO what if this insert fails? We will have inserted the id ->\n  // collName mapping, but there won't be any nodes in the type\n  // collection. Need to create a transaction around this\n  return nodeTypeColl.insert(node)\n}\n\n/**\n * Updates a node in the DB. The contents of `node` will completely\n * overwrite value in the DB. Note, `node` must be a loki node. i.e it\n * has `$loki` and `meta` fields.\n *\n * @param {Object} node The new node information. This should be all\n * the node information. Not just changes\n */\nfunction updateNode(node) {\n  invariant(node.internal, `node has no \"internal\" field`)\n  invariant(node.internal.type, `node has no \"internal.type\" field`)\n  invariant(node.id, `node has no \"id\" field`)\n\n  const type = node.internal.type\n\n  let coll = getNodeTypeCollection(type)\n  invariant(coll, `${type} collection doesn't exist. When trying to update`)\n  coll.update(node)\n}\n\n/**\n * Deletes a node from its type collection and removes its id ->\n * collName mapping. Function is idempotent. If the node has already\n * been deleted, this is a noop.\n *\n * @param {Object} the node to delete. Must have an `id` and\n * `internal.type`\n */\nfunction deleteNode(node) {\n  invariant(node.internal, `node has no \"internal\" field`)\n  invariant(node.internal.type, `node has no \"internal.type\" field`)\n  invariant(node.id, `node has no \"id\" field`)\n\n  const type = node.internal.type\n\n  let nodeTypeColl = getNodeTypeCollection(type)\n  if (!nodeTypeColl) {\n    invariant(\n      nodeTypeColl,\n      `${type} collection doesn't exist. When trying to delete`\n    )\n  }\n\n  if (nodeTypeColl.by(`id`, node.id)) {\n    const nodeMetaColl = getDb().getCollection(colls.nodeMeta.name)\n    invariant(nodeMetaColl, `Collection ${colls.nodeMeta.name} should exist`)\n    nodeMetaColl.findAndRemove({ id: node.id })\n    // TODO What if this `remove()` fails? We will have removed the id\n    // -> collName mapping, but not the actual node in the\n    // collection. Need to make this into a transaction\n    nodeTypeColl.remove(node)\n  }\n  // idempotent. Do nothing if node wasn't already in DB\n}\n\n/**\n * deprecated\n */\nfunction deleteNodes(nodes) {\n  for (const node of nodes) {\n    deleteNode(node)\n  }\n}\n\n/////////////////////////////////////////////////////////////////////\n// Reducer\n/////////////////////////////////////////////////////////////////////\n\nfunction reducer(state = new Map(), action) {\n  switch (action.type) {\n    case `DELETE_CACHE`:\n      deleteAll()\n      return null\n\n    case `CREATE_NODE`: {\n      createNode(action.payload, action.oldNode)\n      return null\n    }\n\n    case `ADD_FIELD_TO_NODE`:\n    case `ADD_CHILD_NODE_TO_PARENT_NODE`:\n      updateNode(action.payload)\n      return null\n\n    case `DELETE_NODE`: {\n      if (action.payload) {\n        deleteNode(action.payload)\n      }\n      return null\n    }\n\n    case `DELETE_NODES`: {\n      deleteNodes(action.payload)\n      return null\n    }\n\n    default:\n      return null\n  }\n}\n\n/////////////////////////////////////////////////////////////////////\n// Exports\n/////////////////////////////////////////////////////////////////////\n\nmodule.exports = {\n  getNodeTypeCollection,\n\n  getNodes,\n  getNode,\n  getNodesByType,\n  getTypes,\n  hasNodeChanged,\n  getNodeAndSavePathDependency,\n\n  createNode,\n  updateNode,\n  deleteNode,\n\n  deleteNodeTypeCollections,\n  deleteAll,\n\n  reducer,\n}\n"],"file":"nodes.js"}