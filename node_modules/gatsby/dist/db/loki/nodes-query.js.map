{"version":3,"sources":["../../../src/db/loki/nodes-query.js"],"names":["_","require","prepareRegex","getNodeTypeCollection","emitter","fieldUsages","FIELD_INDEX_THRESHOLD","on","field","toMongoArgs","gqlFilter","lastFieldType","mongoArgs","each","v","k","isPlainObject","gqlFieldType","ofType","getFields","type","re","obj","isUndefined","test","Minimatch","mm","makeRe","undefined","constructor","name","concat","toDottedFields","filter","acc","path","Object","keys","forEach","key","value","nextValue","join","isNeTrue","length","first","rest","fixNeTrue","reduce","split","convertArgs","gqlArgs","gqlType","toSortFields","sortArgs","fields","order","lokiSortFields","i","dottedField","isDesc","toLowerCase","push","ensureFieldIndexes","coll","lokiArgs","fieldName","update","n","get","ensureIndex","runQuery","queryArgs","firstOnly","JSON","parse","stringify","chain","find","sort","sortFields","sortField","compoundsort","data","module","exports"],"mappings":"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","sourcesContent":["const _ = require(`lodash`)\nconst prepareRegex = require(`../../utils/prepare-regex`)\nconst { getNodeTypeCollection } = require(`./nodes`)\nconst { emitter } = require(`../../redux`)\n\n// Cleared on DELETE_CACHE\nconst fieldUsages = {}\nconst FIELD_INDEX_THRESHOLD = 5\n\nemitter.on(`DELETE_CACHE`, () => {\n  for (var field in fieldUsages) {\n    delete fieldUsages[field]\n  }\n})\n\n// Takes a raw graphql filter and converts it into a mongo-like args\n// object that can be understood by loki. E.g `eq` becomes\n// `$eq`. gqlFilter should be the raw graphql filter returned from\n// graphql-js. e.g gqlFilter:\n//\n// {\n//   internal: {\n//     type: {\n//       eq: \"TestNode\"\n//     },\n//     content: {\n//       glob: \"et\"\n//     }\n//   },\n//   id: {\n//     glob: \"12*\"\n//   }\n// }\n//\n// would return\n//\n// {\n//   internal: {\n//     type: {\n//       $eq: \"TestNode\"  // append $ to eq\n//     },\n//     content: {\n//       $regex: new MiniMatch(v) // convert glob to regex\n//     }\n//   },\n//   id: {\n//     $regex: // as above\n//   }\n// }\nfunction toMongoArgs(gqlFilter, lastFieldType) {\n  const mongoArgs = {}\n  _.each(gqlFilter, (v, k) => {\n    if (_.isPlainObject(v)) {\n      if (k === `elemMatch`) {\n        const gqlFieldType = lastFieldType.ofType\n        mongoArgs[`$elemMatch`] = toMongoArgs(v, gqlFieldType)\n      } else {\n        const gqlFieldType = lastFieldType.getFields()[k].type\n        mongoArgs[k] = toMongoArgs(v, gqlFieldType)\n      }\n    } else {\n      if (k === `regex`) {\n        const re = prepareRegex(v)\n        // To ensure that false is returned if a field doesn't\n        // exist. E.g `{nested.field: {$regex: /.*/}}`\n        mongoArgs[`$where`] = obj => !_.isUndefined(obj) && re.test(obj)\n      } else if (k === `glob`) {\n        const Minimatch = require(`minimatch`).Minimatch\n        const mm = new Minimatch(v)\n        mongoArgs[`$regex`] = mm.makeRe()\n      } else if (k === `eq` && v === null) {\n        mongoArgs[`$in`] = [null, undefined]\n      } else if (\n        k === `eq` &&\n        lastFieldType &&\n        lastFieldType.constructor.name === `GraphQLList`\n      ) {\n        mongoArgs[`$contains`] = v\n      } else if (\n        k === `ne` &&\n        lastFieldType &&\n        lastFieldType.constructor.name === `GraphQLList`\n      ) {\n        mongoArgs[`$containsNone`] = v\n      } else if (\n        k === `in` &&\n        lastFieldType &&\n        lastFieldType.constructor.name === `GraphQLList`\n      ) {\n        mongoArgs[`$containsAny`] = v\n      } else if (\n        k === `nin` &&\n        lastFieldType &&\n        lastFieldType.constructor.name === `GraphQLList`\n      ) {\n        mongoArgs[`$containsNone`] = v\n      } else if (k === `ne` && v === null) {\n        mongoArgs[`$ne`] = undefined\n      } else if (k === `nin` && lastFieldType.name === `Boolean`) {\n        mongoArgs[`$nin`] = v.concat([undefined])\n      } else {\n        mongoArgs[`$${k}`] = v\n      }\n    }\n  })\n  return mongoArgs\n}\n\n// Converts a nested mongo args object into a dotted notation. acc\n// (accumulator) must be a reference to an empty object. The converted\n// fields will be added to it. E.g\n//\n// {\n//   internal: {\n//     type: {\n//       $eq: \"TestNode\"\n//     },\n//     content: {\n//       $regex: new MiniMatch(v)\n//     }\n//   },\n//   id: {\n//     $regex: newMiniMatch(v)\n//   }\n// }\n//\n// After execution, acc would be:\n//\n// {\n//   \"internal.type\": {\n//     $eq: \"TestNode\"\n//   },\n//   \"internal.content\": {\n//     $regex: new MiniMatch(v)\n//   },\n//   \"id\": {\n//     $regex: // as above\n//   }\n// }\nconst toDottedFields = (filter, acc = {}, path = []) => {\n  Object.keys(filter).forEach(key => {\n    const value = filter[key]\n    const nextValue = _.isPlainObject(value) && value[Object.keys(value)[0]]\n    if (key === `$elemMatch`) {\n      acc[path.join(`.`)] = { [`$elemMatch`]: toDottedFields(value) }\n    } else if (_.isPlainObject(nextValue)) {\n      toDottedFields(value, acc, path.concat(key))\n    } else {\n      acc[path.concat(key).join(`.`)] = value\n    }\n  })\n  return acc\n}\n\n// The query language that Gatsby has used since day 1 is `sift`. Both\n// sift and loki are mongo-like query languages, but they have some\n// subtle differences. One is that in sift, a nested filter such as\n// `{foo: {bar: {ne: true} } }` will return true if the foo field\n// doesn't exist, is null, or bar is null. Whereas loki will return\n// false if the foo field doesn't exist or is null. This ensures that\n// loki queries behave like sift\nconst isNeTrue = (obj, path) => {\n  if (path.length) {\n    const [first, ...rest] = path\n    return obj == null || obj[first] == null || isNeTrue(obj[first], rest)\n  } else {\n    return obj !== true\n  }\n}\n\nconst fixNeTrue = filter =>\n  Object.keys(filter).reduce((acc, key) => {\n    const value = filter[key]\n    if (value[`$ne`] === true) {\n      const [first, ...path] = key.split(`.`)\n      acc[first] = { [`$where`]: obj => isNeTrue(obj, path) }\n    } else {\n      acc[key] = value\n    }\n    return acc\n  }, {})\n\n// Converts graphQL args to a loki filter\nconst convertArgs = (gqlArgs, gqlType) =>\n  fixNeTrue(toDottedFields(toMongoArgs(gqlArgs.filter, gqlType)))\n\n// Converts graphql Sort args into the form expected by loki, which is\n// a vector where the first value is a field name, and the second is a\n// boolean `isDesc`. E.g\n//\n// {\n//   fields: [ `frontmatter___date`, `id` ],\n//   order: [`desc`]\n// }\n//\n// would return\n//\n// [ [ `frontmatter.date`, true ], [ `id`, false ] ]\n//\nfunction toSortFields(sortArgs) {\n  const { fields, order } = sortArgs\n  const lokiSortFields = []\n  for (let i = 0; i < fields.length; i++) {\n    const dottedField = fields[i]\n    const isDesc = order[i] && order[i].toLowerCase() === `desc`\n    lokiSortFields.push([dottedField, isDesc])\n  }\n  return lokiSortFields\n}\n\n// Every time we run a query, we increment a counter for each of its\n// fields, so that we can determine which fields are used the\n// most. Any time a field is seen more than `FIELD_INDEX_THRESHOLD`\n// times, we create a loki index so that future queries with that\n// field will execute faster.\nfunction ensureFieldIndexes(coll, lokiArgs) {\n  _.forEach(lokiArgs, (v, fieldName) => {\n    // Increment the usages of the field\n    _.update(fieldUsages, fieldName, n => (n ? n + 1 : 1))\n    // If we have crossed the threshold, then create the index\n    if (_.get(fieldUsages, fieldName) === FIELD_INDEX_THRESHOLD) {\n      // Loki ensures that this is a noop if index already exists. E.g\n      // if it was previously added via a sort field\n      coll.ensureIndex(fieldName)\n    }\n  })\n}\n\n/**\n * Runs the graphql query over the loki nodes db.\n *\n * @param {Object} args. Object with:\n *\n * {Object} gqlType: A GraphQL type\n *\n * {Object} queryArgs: The raw graphql query as a js object. E.g `{\n * filter: { fields { slug: { eq: \"/somepath\" } } } }`\n *\n * {Object} context: The context from the QueryJob\n *\n * {boolean} firstOnly: Whether to return the first found match, or\n * all matching results\n *\n * @returns {promise} A promise that will eventually be resolved with\n * a collection of matching objects (even if `firstOnly` is true)\n */\nasync function runQuery({ gqlType, queryArgs, firstOnly }) {\n  // Clone args as for some reason graphql-js removes the constructor\n  // from nested objects which breaks a check in sift.js.\n  const gqlArgs = JSON.parse(JSON.stringify(queryArgs))\n  const lokiArgs = convertArgs(gqlArgs, gqlType)\n  const coll = getNodeTypeCollection(gqlType.name)\n  ensureFieldIndexes(coll, lokiArgs)\n  let chain = coll.chain().find(lokiArgs, firstOnly)\n\n  if (queryArgs.sort) {\n    const sortFields = toSortFields(queryArgs.sort)\n\n    // Create an index for each sort field. Indexing requires sorting\n    // so we lose nothing by ensuring an index is added for each sort\n    // field. Loki ensures this is a noop if the index already exists\n    for (const sortField of sortFields) {\n      coll.ensureIndex(sortField[0])\n    }\n    chain = chain.compoundsort(sortFields)\n  }\n\n  return chain.data()\n}\n\nmodule.exports = runQuery\n"],"file":"nodes-query.js"}