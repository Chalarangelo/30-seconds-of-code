{"version":3,"sources":["../../src/schema/node-model.js"],"names":["_","require","isAbstractType","GraphQLOutputType","GraphQLUnionType","invariant","LocalNodeModel","constructor","schema","nodeStore","createPageDependency","path","getNodeById","args","pageDependencies","id","type","node","result","nodeTypeNames","toNodeTypeNames","includes","internal","trackPageDependencies","getNodesByIds","ids","nodes","Array","isArray","map","filter","Boolean","length","getAllNodes","getNodes","reduce","acc","typeName","concat","getNodesByType","runQuery","query","firstOnly","gqlType","getType","name","queryResult","queryArgs","getTypes","findRootNodeAncestor","obj","predicate","fullDependencies","connectionType","connection","nodeId","isPlainObject","getNode","gqlTypeName","possibleTypes","getPossibleTypes","getInterfaces","some","iface","module","exports"],"mappings":"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","sourcesContent":["// @flow\n\nconst _ = require(`lodash`)\nconst {\n  isAbstractType,\n  GraphQLOutputType,\n  GraphQLUnionType,\n} = require(`graphql`)\nconst invariant = require(`invariant`)\n\ntype IDOrNode = string | { id: string }\ntype TypeOrTypeName = string | GraphQLOutputType\n\n/**\n * Optional page dependency information.\n *\n * @typedef {Object} PageDependencies\n * @property {string} path The path of the page that depends on the retrieved nodes' data\n * @property {string} [connectionType] Mark this dependency as a connection\n */\ninterface PageDependencies {\n  path: string;\n  connectionType?: string;\n}\n\ninterface QueryArguments {\n  type: TypeOrTypeName;\n  query: { filter: Object, sort?: Object };\n  firstOnly?: boolean;\n}\n\nexport interface NodeModel {\n  getNodeById(\n    { id: IDOrNode, type?: TypeOrTypeName },\n    pageDependencies?: PageDependencies\n  ): any | null;\n  getNodesByIds(\n    { ids: Array<IDOrNode>, type?: TypeOrTypeName },\n    pageDependencies?: PageDependencies\n  ): Array<any>;\n  getAllNodes(\n    { type?: TypeOrTypeName },\n    pageDependencies?: PageDependencies\n  ): Array<any>;\n  runQuery(\n    args: QueryArguments,\n    pageDependencies?: PageDependencies\n  ): Promise<any>;\n  getTypes(): Array<string>;\n  trackPageDependencies<nodeOrNodes: Node | Node[]>(\n    result: nodeOrNodes,\n    pageDependencies?: PageDependencies\n  ): nodesOrNodes;\n}\n\nclass LocalNodeModel {\n  constructor({ schema, nodeStore, createPageDependency, path }) {\n    this.schema = schema\n    this.nodeStore = nodeStore\n    this.createPageDependency = createPageDependency\n    this.path = path\n  }\n\n  /**\n   * Get a node from the store by ID and optional type.\n   *\n   * @param {Object} args\n   * @param {string} args.id ID of the requested node\n   * @param {(string|GraphQLOutputType)} [args.type] Optional type of the node\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {(Node|null)}\n   */\n  getNodeById(args, pageDependencies) {\n    const { id, type } = args || {}\n\n    const node = getNodeById(this.nodeStore, id)\n\n    let result\n    if (!node) {\n      result = null\n    } else if (!type) {\n      result = node\n    } else {\n      const nodeTypeNames = toNodeTypeNames(this.schema, type)\n      result = nodeTypeNames.includes(node.internal.type) ? node : null\n    }\n\n    return this.trackPageDependencies(result, pageDependencies)\n  }\n\n  /**\n   * Get nodes from the store by IDs and optional type.\n   *\n   * @param {Object} args\n   * @param {string[]} args.ids IDs of the requested nodes\n   * @param {(string|GraphQLOutputType)} [args.type] Optional type of the nodes\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Node[]}\n   */\n  getNodesByIds(args, pageDependencies) {\n    const { ids, type } = args || {}\n\n    const nodes = Array.isArray(ids)\n      ? ids.map(id => getNodeById(this.nodeStore, id)).filter(Boolean)\n      : []\n\n    let result\n    if (!nodes.length || !type) {\n      result = nodes\n    } else {\n      const nodeTypeNames = toNodeTypeNames(this.schema, type)\n      result = nodes.filter(node => nodeTypeNames.includes(node.internal.type))\n    }\n\n    return this.trackPageDependencies(result, pageDependencies)\n  }\n\n  /**\n   * Get all nodes in the store, or all nodes of a specified type. Note that\n   * this doesn't add tracking to all the nodes, unless pageDependencies are\n   * passed.\n   *\n   * @param {Object} args\n   * @param {(string|GraphQLOutputType)} [args.type] Optional type of the nodes\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Node[]}\n   */\n  getAllNodes(args, pageDependencies) {\n    const { type } = args || {}\n\n    let result\n    if (!type) {\n      result = this.nodeStore.getNodes()\n    } else {\n      const nodeTypeNames = toNodeTypeNames(this.schema, type)\n      const nodes = nodeTypeNames.reduce(\n        (acc, typeName) => acc.concat(this.nodeStore.getNodesByType(typeName)),\n        []\n      )\n      result = nodes.filter(Boolean)\n    }\n\n    if (pageDependencies) {\n      return this.trackPageDependencies(result, pageDependencies)\n    } else {\n      return result\n    }\n  }\n\n  /**\n   * Get nodes of a type matching the specified query.\n   *\n   * @param {Object} args\n   * @param {Object} args.query Query arguments (`filter` and `sort`)\n   * @param {(string|GraphQLOutputType)} args.type Type\n   * @param {boolean} [args.firstOnly] If true, return only first match\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Promise<Node[]>}\n   */\n  async runQuery(args, pageDependencies) {\n    const { query, firstOnly, type } = args || {}\n\n    // We don't support querying union types (yet?), because the combined types\n    // need not have any fields in common.\n    const gqlType = typeof type === `string` ? this.schema.getType(type) : type\n    invariant(\n      !(gqlType instanceof GraphQLUnionType),\n      `Querying GraphQLUnion types is not supported.`\n    )\n\n    // We provide nodes in case of abstract types, because `run-sift` should\n    // only need to know about node types in the store.\n    let nodes\n    let nodeTypeNames\n    if (isAbstractType(gqlType)) {\n      nodeTypeNames = toNodeTypeNames(this.schema, gqlType)\n      nodes = nodeTypeNames.reduce(\n        (acc, typeName) => acc.concat(this.nodeStore.getNodesByType(typeName)),\n        []\n      )\n    } else {\n      nodeTypeNames = [gqlType.name]\n    }\n\n    const queryResult = await this.nodeStore.runQuery({\n      queryArgs: query,\n      firstOnly,\n      gqlType,\n      nodes,\n      nodeTypeNames,\n    })\n\n    let result = queryResult\n    if (args.firstOnly) {\n      if (result && result.length > 0) {\n        result = result[0]\n      } else {\n        result = null\n      }\n    }\n\n    return this.trackPageDependencies(result, pageDependencies)\n  }\n\n  /**\n   * Get the names of all node types in the store.\n   *\n   * @returns {string[]}\n   */\n  getTypes() {\n    return this.nodeStore.getTypes()\n  }\n\n  /**\n   * Get the root ancestor node for an object's parent node, or its first\n   * ancestor matching a specified condition.\n   *\n   * @param {(Object|Array)} obj An object belonging to a Node, or a Node object\n   * @param {Function} [predicate] Optional condition to match\n   * @returns {(Node|null)}\n   */\n  findRootNodeAncestor(obj, predicate) {\n    return this.nodeStore.findRootNodeAncestor(obj, predicate)\n  }\n\n  /**\n   * Given a result, that's either a single node or an array of them, track them\n   * using pageDependencies. Defaults to tracking according to current resolver\n   * path. Returns the result back.\n   *\n   * @param {Node | Node[]} result\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Node | Node[]}\n   */\n  trackPageDependencies(result, pageDependencies) {\n    const fullDependencies = {\n      path: this.path,\n      ...(pageDependencies || {}),\n    }\n    const { path, connectionType } = fullDependencies\n    if (path) {\n      if (connectionType) {\n        this.createPageDependency({ path, connection: connectionType })\n      } else {\n        const nodes = Array.isArray(result) ? result : [result]\n        nodes\n          .filter(Boolean)\n          .map(node => this.createPageDependency({ path, nodeId: node.id }))\n      }\n    }\n\n    return result\n  }\n}\n\nconst getNodeById = (nodeStore, id) => {\n  // This is for cases when the `id` has already been resolved\n  // to a full Node for the input filter, and is also in the selection\n  // set. E.g. `{ foo(parent: { id: { eq: 1 } } ) { parent { id } } }`.\n  if (_.isPlainObject(id) && id.id) {\n    return id\n  }\n  return id != null ? nodeStore.getNode(id) : null\n}\n\nconst toNodeTypeNames = (schema, gqlTypeName) => {\n  const gqlType =\n    typeof gqlTypeName === `string` ? schema.getType(gqlTypeName) : gqlTypeName\n\n  if (!gqlType) return []\n\n  const possibleTypes = isAbstractType(gqlType)\n    ? schema.getPossibleTypes(gqlType)\n    : [gqlType]\n\n  return possibleTypes\n    .filter(type => type.getInterfaces().some(iface => iface.name === `Node`))\n    .map(type => type.name)\n}\n\nmodule.exports = {\n  LocalNodeModel,\n}\n"],"file":"node-model.js"}