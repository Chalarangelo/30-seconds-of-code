{"version":3,"sources":["../../src/redux/run-sift.js"],"names":["sift","require","_","prepareRegex","resolveNodes","resolveRecursive","makeRe","getQueryFields","getValueAt","prepareQueryArgs","filterFields","Object","keys","reduce","acc","key","value","isPlainObject","getFilters","filters","push","isEqId","firstOnly","fieldsToSift","siftArgs","length","id","handleFirst","nodes","index","isEmpty","indexOf","$and","handleMany","sort","result","sortFields","fields","map","field","v","sortOrder","order","toLowerCase","orderBy","module","exports","args","getNode","getNodesByType","queryArgs","gqlType","nodeTypeNames","name","filter","group","distinct","siftFilter","node","internal","includes","type","getFields","then","resolvedNodes"],"mappings":"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","sourcesContent":["// @flow\nconst sift = require(`sift`)\nconst _ = require(`lodash`)\nconst prepareRegex = require(`../utils/prepare-regex`)\nconst { resolveNodes, resolveRecursive } = require(`./prepare-nodes`)\nconst { makeRe } = require(`micromatch`)\nconst { getQueryFields } = require(`../db/common/query`)\nconst { getValueAt } = require(`../utils/get-value-at`)\n\n/////////////////////////////////////////////////////////////////////\n// Parse filter\n/////////////////////////////////////////////////////////////////////\n\nconst prepareQueryArgs = (filterFields = {}) =>\n  Object.keys(filterFields).reduce((acc, key) => {\n    const value = filterFields[key]\n    if (_.isPlainObject(value)) {\n      acc[key === `elemMatch` ? `$elemMatch` : key] = prepareQueryArgs(value)\n    } else {\n      switch (key) {\n        case `regex`:\n          acc[`$regex`] = prepareRegex(value)\n          break\n        case `glob`:\n          acc[`$regex`] = makeRe(value)\n          break\n        default:\n          acc[`$${key}`] = value\n      }\n    }\n    return acc\n  }, {})\n\nconst getFilters = filters =>\n  Object.keys(filters).reduce(\n    (acc, key) => acc.push({ [key]: filters[key] }) && acc,\n    []\n  )\n\n/////////////////////////////////////////////////////////////////////\n// Run Sift\n/////////////////////////////////////////////////////////////////////\n\nfunction isEqId(firstOnly, fieldsToSift, siftArgs) {\n  return (\n    firstOnly &&\n    Object.keys(fieldsToSift).length === 1 &&\n    Object.keys(fieldsToSift)[0] === `id` &&\n    Object.keys(siftArgs[0].id).length === 1 &&\n    Object.keys(siftArgs[0].id)[0] === `$eq`\n  )\n}\n\nfunction handleFirst(siftArgs, nodes) {\n  const index = _.isEmpty(siftArgs)\n    ? 0\n    : sift.indexOf(\n        {\n          $and: siftArgs,\n        },\n        nodes\n      )\n\n  if (index !== -1) {\n    return [nodes[index]]\n  } else {\n    return []\n  }\n}\n\nfunction handleMany(siftArgs, nodes, sort) {\n  let result = _.isEmpty(siftArgs)\n    ? nodes\n    : sift(\n        {\n          $and: siftArgs,\n        },\n        nodes\n      )\n\n  if (!result || !result.length) return null\n\n  // Sort results.\n  if (sort) {\n    // create functions that return the item to compare on\n    const sortFields = sort.fields.map(field => v => getValueAt(v, field))\n    const sortOrder = sort.order.map(order => order.toLowerCase())\n\n    result = _.orderBy(result, sortFields, sortOrder)\n  }\n  return result\n}\n\n/**\n * Filters a list of nodes using mongodb-like syntax.\n *\n * @param args raw graphql query filter as an object\n * @param nodes The nodes array to run sift over (Optional\n *   will load itself if not present)\n * @param type gqlType. Created in build-node-types\n * @param firstOnly true if you want to return only the first result\n *   found. This will return a collection of size 1. Not a single\n *   element\n * @returns Collection of results. Collection will be limited to size\n *   if `firstOnly` is true\n */\nmodule.exports = (args: Object) => {\n  const { getNode, getNodesByType } = require(`../db/nodes`)\n\n  const { queryArgs, gqlType, firstOnly = false, nodeTypeNames } = args\n\n  // If nodes weren't provided, then load them from the DB\n  const nodes = args.nodes || getNodesByType(gqlType.name)\n\n  const { filter, sort, group, distinct } = queryArgs\n  const siftFilter = getFilters(prepareQueryArgs(filter))\n  const fieldsToSift = getQueryFields({ filter, sort, group, distinct })\n\n  // If the the query for single node only has a filter for an \"id\"\n  // using \"eq\" operator, then we'll just grab that ID and return it.\n  if (isEqId(firstOnly, fieldsToSift, siftFilter)) {\n    const node = getNode(siftFilter[0].id[`$eq`])\n\n    if (\n      !node ||\n      (node.internal && !nodeTypeNames.includes(node.internal.type))\n    ) {\n      return []\n    }\n\n    return resolveRecursive(node, fieldsToSift, gqlType.getFields()).then(\n      node => (node ? [node] : [])\n    )\n  }\n\n  return resolveNodes(\n    nodes,\n    gqlType.name,\n    firstOnly,\n    fieldsToSift,\n    gqlType.getFields()\n  ).then(resolvedNodes => {\n    if (firstOnly) {\n      return handleFirst(siftFilter, resolvedNodes)\n    } else {\n      return handleMany(siftFilter, resolvedNodes, queryArgs.sort)\n    }\n  })\n}\n"],"file":"run-sift.js"}