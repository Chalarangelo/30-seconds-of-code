"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _safeSharp = _interopRequireDefault(require("./safe-sharp"));

var _gatsbyCoreUtils = require("gatsby-core-utils");

var _common = require("./common");

_safeSharp.default.simd(true); // Handle Sharp's concurrency based on the Gatsby CPU count
// See: http://sharp.pixelplumbing.com/en/stable/api-utility/#concurrency
// See: https://www.gatsbyjs.org/docs/multi-core-builds/


_safeSharp.default.concurrency((0, _gatsbyCoreUtils.cpuCoreCount)());

function generateIcon(_x, _x2) {
  return _generateIcon.apply(this, arguments);
}

function _generateIcon() {
  _generateIcon = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee3(icon, srcIcon) {
    var imgPath, size, density;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            imgPath = _path.default.join("public", icon.src); // console.log(`generating icon: `, icon.src)
            // if (fs.existsSync(imgPath)) {
            //   console.log(`icon already Exists, not regenerating`)
            //   return true
            // }

            size = parseInt(icon.sizes.substring(0, icon.sizes.lastIndexOf("x"))); // For vector graphics, instruct sharp to use a pixel density
            // suitable for the resolution we're rasterizing to.
            // For pixel graphics sources this has no effect.
            // Sharp accept density from 1 to 2400

            density = Math.min(2400, Math.max(1, size));
            return _context3.abrupt("return", (0, _safeSharp.default)(srcIcon, {
              density: density
            }).resize({
              width: size,
              height: size,
              fit: "contain",
              background: {
                r: 255,
                g: 255,
                b: 255,
                alpha: 0
              }
            }).toFile(imgPath));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _generateIcon.apply(this, arguments);
}

function checkCache(_x3, _x4, _x5, _x6, _x7) {
  return _checkCache.apply(this, arguments);
}

function _checkCache() {
  _checkCache = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee4(cache, icon, srcIcon, srcIconDigest, callback) {
    var cacheKey, created;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            cacheKey = (0, _gatsbyCoreUtils.createContentDigest)("" + icon.src + srcIcon + srcIconDigest);
            created = cache.get(cacheKey, srcIcon);

            if (created) {
              _context4.next = 15;
              break;
            }

            cache.set(cacheKey, true);
            _context4.prev = 4;
            _context4.next = 7;
            return callback(icon, srcIcon);

          case 7:
            _context4.next = 13;
            break;

          case 9:
            _context4.prev = 9;
            _context4.t0 = _context4["catch"](4);
            cache.set(cacheKey, false);
            throw _context4.t0;

          case 13:
            _context4.next = 15;
            break;

          case 15:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this, [[4, 9]]);
  }));
  return _checkCache.apply(this, arguments);
}

exports.onPostBootstrap =
/*#__PURE__*/
function () {
  var _ref3 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(_ref, _ref2) {
    var reporter, localize, manifest, activity, cache, locales;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            reporter = _ref.reporter;
            localize = _ref2.localize, manifest = (0, _objectWithoutPropertiesLoose2.default)(_ref2, ["localize"]);
            activity = reporter.activityTimer("Build manifest and related icons");
            activity.start();
            cache = new Map();
            _context.next = 7;
            return makeManifest(cache, reporter, manifest);

          case 7:
            if (!Array.isArray(localize)) {
              _context.next = 11;
              break;
            }

            locales = localize.concat();
            _context.next = 11;
            return Promise.all(locales.map(function (locale) {
              var cacheModeOverride = {};
              /* localization requires unique filenames for output files if a different src Icon is defined.
                 otherwise one language would override anothers icons in automatic mode.
              */

              if (locale.hasOwnProperty("icon") && !locale.hasOwnProperty("icons")) {
                // console.debug(`OVERRIDING CACHE BUSTING`, locale)
                cacheModeOverride = {
                  cache_busting_mode: "name"
                };
              }

              return makeManifest(cache, reporter, (0, _extends2.default)({}, manifest, locale, cacheModeOverride));
            }));

          case 11:
            activity.end();

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function (_x8, _x9) {
    return _ref3.apply(this, arguments);
  };
}();

var makeManifest =
/*#__PURE__*/
function () {
  var _ref4 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee2(cache, reporter, pluginOptions) {
    var icon, manifest, suffix, paths, sharpIcon, metadata, cacheMode, iconDigest;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            icon = pluginOptions.icon, manifest = (0, _objectWithoutPropertiesLoose2.default)(pluginOptions, ["icon"]);
            suffix = pluginOptions.lang ? "_" + pluginOptions.lang : ""; // Delete options we won't pass to the manifest.webmanifest.

            delete manifest.plugins;
            delete manifest.legacy;
            delete manifest.theme_color_in_head;
            delete manifest.cache_busting_mode;
            delete manifest.crossOrigin;
            delete manifest.icon_options;
            delete manifest.include_favicon; // If icons are not manually defined, use the default icon set.

            if (!manifest.icons) {
              manifest.icons = _common.defaultIcons.concat();
            } // Specify extra options for each icon (if requested).


            if (pluginOptions.icon_options) {
              manifest.icons = manifest.icons.map(function (icon) {
                return (0, _extends2.default)({}, pluginOptions.icon_options, icon);
              });
            } // Determine destination path for icons.


            paths = {};
            manifest.icons.forEach(function (icon) {
              var iconPath = _path.default.join("public", _path.default.dirname(icon.src));

              if (!paths[iconPath]) {
                var exists = _fs.default.existsSync(iconPath); //create destination directory if it doesn't exist


                if (!exists) {
                  _fs.default.mkdirSync(iconPath);
                }

                paths[iconPath] = true;
              }
            }); // Only auto-generate icons if a src icon is defined.

            if (!(icon !== undefined)) {
              _context2.next = 30;
              break;
            }

            if ((0, _common.doesIconExist)(icon)) {
              _context2.next = 16;
              break;
            }

            throw "icon (" + icon + ") does not exist as defined in gatsby-config.js. Make sure the file exists relative to the root of the site.";

          case 16:
            sharpIcon = (0, _safeSharp.default)(icon);
            _context2.next = 19;
            return sharpIcon.metadata();

          case 19:
            metadata = _context2.sent;

            if (metadata.width !== metadata.height) {
              reporter.warn("The icon(" + icon + ") you provided to 'gatsby-plugin-manifest' is not square.\n" + "The icons we generate will be square and for the best results we recommend you provide a square icon.\n");
            } //add cache busting


            cacheMode = typeof pluginOptions.cache_busting_mode !== "undefined" ? pluginOptions.cache_busting_mode : "query";
            iconDigest = (0, _gatsbyCoreUtils.createContentDigest)(_fs.default.readFileSync(icon)); //if cacheBusting is being done via url query icons must be generated before cache busting runs

            if (!(cacheMode === "query")) {
              _context2.next = 26;
              break;
            }

            _context2.next = 26;
            return Promise.all(manifest.icons.map(function (dstIcon) {
              return checkCache(cache, dstIcon, icon, iconDigest, generateIcon);
            }));

          case 26:
            if (cacheMode !== "none") {
              manifest.icons = manifest.icons.map(function (icon) {
                var newIcon = (0, _extends2.default)({}, icon);
                newIcon.src = (0, _common.addDigestToPath)(icon.src, iconDigest, cacheMode);
                return newIcon;
              });
            } //if file names are being modified by cacheBusting icons must be generated after cache busting runs


            if (!(cacheMode !== "query")) {
              _context2.next = 30;
              break;
            }

            _context2.next = 30;
            return Promise.all(manifest.icons.map(function (dstIcon) {
              return checkCache(cache, dstIcon, icon, iconDigest, generateIcon);
            }));

          case 30:
            //Write manifest
            _fs.default.writeFileSync(_path.default.join("public", "manifest" + suffix + ".webmanifest"), JSON.stringify(manifest));

          case 31:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function makeManifest(_x10, _x11, _x12) {
    return _ref4.apply(this, arguments);
  };
}();