#!/usr/bin/env node
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = require('path');
var path__default = _interopDefault(path);
var module$1 = _interopDefault(require('module'));
var os = _interopDefault(require('os'));
var rollup = require('../dist/rollup.js');
var rollup__default = _interopDefault(rollup);
var assert = _interopDefault(require('assert'));
var events = _interopDefault(require('events'));
var fs = require('fs');
var fs__default = _interopDefault(fs);

var minimist = function (args, opts) {
    if (!opts) opts = {};
    
    var flags = { bools : {}, strings : {}, unknownFn: null };

    if (typeof opts['unknown'] === 'function') {
        flags.unknownFn = opts['unknown'];
    }

    if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
      flags.allBools = true;
    } else {
      [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
          flags.bools[key] = true;
      });
    }
    
    var aliases = {};
    Object.keys(opts.alias || {}).forEach(function (key) {
        aliases[key] = [].concat(opts.alias[key]);
        aliases[key].forEach(function (x) {
            aliases[x] = [key].concat(aliases[key].filter(function (y) {
                return x !== y;
            }));
        });
    });

    [].concat(opts.string).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true;
        if (aliases[key]) {
            flags.strings[aliases[key]] = true;
        }
     });

    var defaults = opts['default'] || {};
    
    var argv = { _ : [] };
    Object.keys(flags.bools).forEach(function (key) {
        setArg(key, defaults[key] === undefined ? false : defaults[key]);
    });
    
    var notFlags = [];

    if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--')+1);
        args = args.slice(0, args.indexOf('--'));
    }

    function argDefined(key, arg) {
        return (flags.allBools && /^--[^=]+$/.test(arg)) ||
            flags.strings[key] || flags.bools[key] || aliases[key];
    }

    function setArg (key, val, arg) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg) === false) return;
        }

        var value = !flags.strings[key] && isNumber(val)
            ? Number(val) : val
        ;
        setKey(argv, key.split('.'), value);
        
        (aliases[key] || []).forEach(function (x) {
            setKey(argv, x.split('.'), value);
        });
    }

    function setKey (obj, keys, value) {
        var o = obj;
        keys.slice(0,-1).forEach(function (key) {
            if (o[key] === undefined) o[key] = {};
            o = o[key];
        });

        var key = keys[keys.length - 1];
        if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
            o[key] = value;
        }
        else if (Array.isArray(o[key])) {
            o[key].push(value);
        }
        else {
            o[key] = [ o[key], value ];
        }
    }
    
    function aliasIsBoolean(key) {
      return aliases[key].some(function (x) {
          return flags.bools[x];
      });
    }

    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        
        if (/^--.+=/.test(arg)) {
            // Using [\s\S] instead of . because js doesn't support the
            // 'dotall' regex modifier. See:
            // http://stackoverflow.com/a/1068308/13216
            var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
            var key = m[1];
            var value = m[2];
            if (flags.bools[key]) {
                value = value !== 'false';
            }
            setArg(key, value, arg);
        }
        else if (/^--no-.+/.test(arg)) {
            var key = arg.match(/^--no-(.+)/)[1];
            setArg(key, false, arg);
        }
        else if (/^--.+/.test(arg)) {
            var key = arg.match(/^--(.+)/)[1];
            var next = args[i + 1];
            if (next !== undefined && !/^-/.test(next)
            && !flags.bools[key]
            && !flags.allBools
            && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i++;
            }
            else if (/^(true|false)$/.test(next)) {
                setArg(key, next === 'true', arg);
                i++;
            }
            else {
                setArg(key, flags.strings[key] ? '' : true, arg);
            }
        }
        else if (/^-[^-]+/.test(arg)) {
            var letters = arg.slice(1,-1).split('');
            
            var broken = false;
            for (var j = 0; j < letters.length; j++) {
                var next = arg.slice(j+2);
                
                if (next === '-') {
                    setArg(letters[j], next, arg);
                    continue;
                }
                
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                    setArg(letters[j], next.split('=')[1], arg);
                    broken = true;
                    break;
                }
                
                if (/[A-Za-z]/.test(letters[j])
                && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                
                if (letters[j+1] && letters[j+1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j+2), arg);
                    broken = true;
                    break;
                }
                else {
                    setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                }
            }
            
            var key = arg.slice(-1)[0];
            if (!broken && key !== '-') {
                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                && !flags.bools[key]
                && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i+1], arg);
                    i++;
                }
                else if (args[i+1] && /true|false/.test(args[i+1])) {
                    setArg(key, args[i+1] === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
        }
        else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv._.push(
                    flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                );
            }
            if (opts.stopEarly) {
                argv._.push.apply(argv._, args.slice(i + 1));
                break;
            }
        }
    }
    
    Object.keys(defaults).forEach(function (key) {
        if (!hasKey(argv, key.split('.'))) {
            setKey(argv, key.split('.'), defaults[key]);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), defaults[key]);
            });
        }
    });
    
    if (opts['--']) {
        argv['--'] = new Array();
        notFlags.forEach(function(key) {
            argv['--'].push(key);
        });
    }
    else {
        notFlags.forEach(function(key) {
            argv._.push(key);
        });
    }

    return argv;
};

function hasKey (obj, keys) {
    var o = obj;
    keys.slice(0,-1).forEach(function (key) {
        o = (o[key] || {});
    });

    var key = keys[keys.length - 1];
    return key in o;
}

function isNumber (x) {
    if (typeof x === 'number') return true;
    if (/^0x[0-9a-f]+$/i.test(x)) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}

var help = "rollup version __VERSION__\n=====================================\n\nUsage: rollup [options] <entry file>\n\nBasic options:\n\n-v, --version               Show version number\n-h, --help                  Show this help message\n-c, --config                Use this config file (if argument is used but value\n                              is unspecified, defaults to rollup.config.js)\n-w, --watch                 Watch files in bundle and rebuild on changes\n-i, --input                 Input (alternative to <entry file>)\n-o, --file <output>         Output (if absent, prints to stdout)\n-f, --format [es]           Type of output (amd, cjs, es, iife, umd)\n-e, --external              Comma-separate list of module IDs to exclude\n-g, --globals               Comma-separate list of `module ID:Global` pairs\n                              Any module IDs defined here are added to external\n-n, --name                  Name for UMD export\n-m, --sourcemap             Generate sourcemap (`-m inline` for inline map)\n-l, --legacy                Support IE8\n--amd.id                    ID for AMD module (default is anonymous)\n--amd.define                Function to use in place of `define`\n--no-strict                 Don't emit a `\"use strict\";` in the generated modules.\n--no-indent                 Don't indent result\n--environment <values>      Settings passed to config file (see example)\n--no-conflict               Generate a noConflict method for UMD globals\n--no-treeshake              Disable tree-shaking\n--silent                    Don't print warnings\n--intro                     Content to insert at top of bundle (inside wrapper)\n--outro                     Content to insert at end of bundle (inside wrapper)\n--banner                    Content to insert at top of bundle (outside wrapper)\n--footer                    Content to insert at end of bundle (outside wrapper)\n--no-interop                Do not include interop block\n\nExamples:\n\n# use settings in config file\nrollup -c\n\n# in config file, process.env.INCLUDE_DEPS === 'true'\n# and process.env.BUILD === 'production'\nrollup -c --environment INCLUDE_DEPS,BUILD:production\n\n# create CommonJS bundle.js from src/main.js\nrollup --format=cjs --file=bundle.js -- src/main.js\n\n# create self-executing IIFE using `window.jQuery`\n# and `window._` as external globals\nrollup -f iife --globals jquery:jQuery,lodash:_ \\\n  -i src/app.js -o build/app.js -m build/app.js.map\n\nNotes:\n\n* When piping to stdout, only inline sourcemaps are permitted\n\nFor more information visit https://rollupjs.org\n";

var version = "0.58.2";

var modules = {};

var getModule = function(dir) {
  var rootPath = dir ? path__default.resolve(dir) : process.cwd();
  var rootName = path__default.join(rootPath, '@root');
  var root = modules[rootName];
  if (!root) {
    root = new module$1(rootName);
    root.filename = rootName;
    root.paths = module$1._nodeModulePaths(rootPath);
    modules[rootName] = root;
  }
  return root;
};

var requireRelative = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return root.require(requested);
};

requireRelative.resolve = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return module$1._resolveFilename(requested, root);
};

var requireRelative_1 = requireRelative;

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

var escapeStringRegexp = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};

var escapeStringRegexp$1 = /*#__PURE__*/Object.freeze({
    default: escapeStringRegexp,
    __moduleExports: escapeStringRegexp
});

var colorName = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var colorName$1 = /*#__PURE__*/Object.freeze({
    default: colorName,
    __moduleExports: colorName
});

var cssKeywords = ( colorName$1 && colorName ) || colorName$1;

var conversions = createCommonjsModule(function (module) {
/* MIT license */


// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var v;

	if (max === 0) {
		s = 0;
	} else {
		s = (delta / max * 1000) / 10;
	}

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	v = ((max / 255) * 1000) / 10;

	return [h, s, v];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};
});
var conversions_1 = conversions.rgb;
var conversions_2 = conversions.hsl;
var conversions_3 = conversions.hsv;
var conversions_4 = conversions.hwb;
var conversions_5 = conversions.cmyk;
var conversions_6 = conversions.xyz;
var conversions_7 = conversions.lab;
var conversions_8 = conversions.lch;
var conversions_9 = conversions.hex;
var conversions_10 = conversions.keyword;
var conversions_11 = conversions.ansi16;
var conversions_12 = conversions.ansi256;
var conversions_13 = conversions.hcg;
var conversions_14 = conversions.apple;
var conversions_15 = conversions.gray;

var conversions$1 = /*#__PURE__*/Object.freeze({
    default: conversions,
    __moduleExports: conversions,
    rgb: conversions_1,
    hsl: conversions_2,
    hsv: conversions_3,
    hwb: conversions_4,
    cmyk: conversions_5,
    xyz: conversions_6,
    lab: conversions_7,
    lch: conversions_8,
    hex: conversions_9,
    keyword: conversions_10,
    ansi16: conversions_11,
    ansi256: conversions_12,
    hcg: conversions_13,
    apple: conversions_14,
    gray: conversions_15
});

var conversions$2 = ( conversions$1 && conversions ) || conversions$1;

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions$2);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions$2[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path$$1 = [graph[toModel].parent, toModel];
	var fn = conversions$2[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path$$1.unshift(graph[cur].parent);
		fn = link(conversions$2[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path$$1;
	return fn;
}

var route = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};

var route$1 = /*#__PURE__*/Object.freeze({
    default: route,
    __moduleExports: route
});

var route$2 = ( route$1 && route ) || route$1;

var convert = {};

var models = Object.keys(conversions$2);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions$2[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions$2[fromModel].labels});

	var routes = route$2(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

var colorConvert = convert;

var colorConvert$1 = /*#__PURE__*/Object.freeze({
    default: colorConvert,
    __moduleExports: colorConvert
});

var colorConvert$2 = ( colorConvert$1 && colorConvert ) || colorConvert$1;

var ansiStyles = createCommonjsModule(function (module) {


const wrapAnsi16 = (fn, offset) => function () {
	const code = fn.apply(colorConvert$2, arguments);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => function () {
	const code = fn.apply(colorConvert$2, arguments);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => function () {
	const rgb = fn.apply(colorConvert$2, arguments);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39],

			// Bright color
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Fix humans
	styles.color.grey = styles.color.gray;

	for (const groupName of Object.keys(styles)) {
		const group = styles[groupName];

		for (const styleName of Object.keys(group)) {
			const style = group[styleName];

			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});

		Object.defineProperty(styles, 'codes', {
			value: codes,
			enumerable: false
		});
	}

	const ansi2ansi = n => n;
	const rgb2rgb = (r, g, b) => [r, g, b];

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	styles.color.ansi = {
		ansi: wrapAnsi16(ansi2ansi, 0)
	};
	styles.color.ansi256 = {
		ansi256: wrapAnsi256(ansi2ansi, 0)
	};
	styles.color.ansi16m = {
		rgb: wrapAnsi16m(rgb2rgb, 0)
	};

	styles.bgColor.ansi = {
		ansi: wrapAnsi16(ansi2ansi, 10)
	};
	styles.bgColor.ansi256 = {
		ansi256: wrapAnsi256(ansi2ansi, 10)
	};
	styles.bgColor.ansi16m = {
		rgb: wrapAnsi16m(rgb2rgb, 10)
	};

	for (let key of Object.keys(colorConvert$2)) {
		if (typeof colorConvert$2[key] !== 'object') {
			continue;
		}

		const suite = colorConvert$2[key];

		if (key === 'ansi16') {
			key = 'ansi';
		}

		if ('ansi16' in suite) {
			styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
			styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
		}

		if ('ansi256' in suite) {
			styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
			styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
		}

		if ('rgb' in suite) {
			styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
			styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
		}
	}

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});
});

var ansiStyles$1 = /*#__PURE__*/Object.freeze({
    default: ansiStyles,
    __moduleExports: ansiStyles
});

var hasFlag = (flag, argv) => {
	argv = argv || process.argv;
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const pos = argv.indexOf(prefix + flag);
	const terminatorPos = argv.indexOf('--');
	return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};

var hasFlag$1 = /*#__PURE__*/Object.freeze({
    default: hasFlag,
    __moduleExports: hasFlag
});

var hasFlag$2 = ( hasFlag$1 && hasFlag ) || hasFlag$1;

const env = process.env;

let forceColor;
if (hasFlag$2('no-color') ||
	hasFlag$2('no-colors') ||
	hasFlag$2('color=false')) {
	forceColor = false;
} else if (hasFlag$2('color') ||
	hasFlag$2('colors') ||
	hasFlag$2('color=true') ||
	hasFlag$2('color=always')) {
	forceColor = true;
}
if ('FORCE_COLOR' in env) {
	forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(stream) {
	if (forceColor === false) {
		return 0;
	}

	if (hasFlag$2('color=16m') ||
		hasFlag$2('color=full') ||
		hasFlag$2('color=truecolor')) {
		return 3;
	}

	if (hasFlag$2('color=256')) {
		return 2;
	}

	if (stream && !stream.isTTY && forceColor !== true) {
		return 0;
	}

	const min = forceColor ? 1 : 0;

	if (process.platform === 'win32') {
		// Node.js 7.5.0 is the first version of Node.js to include a patch to
		// libuv that enables 256 color output on Windows. Anything earlier and it
		// won't work. However, here we target Node.js 8 at minimum as it is an LTS
		// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
		// release that supports 256 colors. Windows 10 build 14931 is the first release
		// that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(process.versions.node.split('.')[0]) >= 8 &&
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	if (env.TERM === 'dumb') {
		return min;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream);
	return translateLevel(level);
}

var supportsColor_1 = {
	supportsColor: getSupportLevel,
	stdout: getSupportLevel(process.stdout),
	stderr: getSupportLevel(process.stderr)
};
var supportsColor_2 = supportsColor_1.supportsColor;
var supportsColor_3 = supportsColor_1.stdout;
var supportsColor_4 = supportsColor_1.stderr;

var supportsColor$1 = /*#__PURE__*/Object.freeze({
    default: supportsColor_1,
    __moduleExports: supportsColor_1,
    supportsColor: supportsColor_2,
    stdout: supportsColor_3,
    stderr: supportsColor_4
});

const TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) {
	if ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, args) {
	const results = [];
	const chunks = args.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		if (!isNaN(chunk)) {
			results.push(Number(chunk));
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const styleName of Object.keys(enabled)) {
		if (Array.isArray(enabled[styleName])) {
			if (!(styleName in current)) {
				throw new Error(`Unknown Chalk style: ${styleName}`);
			}

			if (enabled[styleName].length > 0) {
				current = current[styleName].apply(current, enabled[styleName]);
			} else {
				current = current[styleName];
			}
		}
	}

	return current;
}

var templates = (chalk, tmp) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
		if (escapeChar) {
			chunk.push(unescape(escapeChar));
		} else if (style) {
			const str = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(chr);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMsg);
	}

	return chunks.join('');
};

var templates$1 = /*#__PURE__*/Object.freeze({
    default: templates,
    __moduleExports: templates
});

var escapeStringRegexp$2 = ( escapeStringRegexp$1 && escapeStringRegexp ) || escapeStringRegexp$1;

var ansiStyles$2 = ( ansiStyles$1 && ansiStyles ) || ansiStyles$1;

var require$$0 = ( supportsColor$1 && supportsColor_1 ) || supportsColor$1;

var template = ( templates$1 && templates ) || templates$1;

var chalk = createCommonjsModule(function (module) {


const stdoutColor = require$$0.stdout;



const isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');

// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping
const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];

// `color-convert` models to exclude from the Chalk API due to conflicts and such
const skipModels = new Set(['gray']);

const styles = Object.create(null);

function applyOptions(obj, options) {
	options = options || {};

	// Detect level if not set manually
	const scLevel = stdoutColor ? stdoutColor.level : 0;
	obj.level = options.level === undefined ? scLevel : options.level;
	obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
}

function Chalk(options) {
	// We check for this.template here since calling `chalk.constructor()`
	// by itself will have a `this` of a previously constructed chalk object
	if (!this || !(this instanceof Chalk) || this.template) {
		const chalk = {};
		applyOptions(chalk, options);

		chalk.template = function () {
			const args = [].slice.call(arguments);
			return chalkTag.apply(null, [chalk.template].concat(args));
		};

		Object.setPrototypeOf(chalk, Chalk.prototype);
		Object.setPrototypeOf(chalk.template, chalk);

		chalk.template.constructor = Chalk;

		return chalk.template;
	}

	applyOptions(this, options);
}

// Use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles$2.blue.open = '\u001B[94m';
}

for (const key of Object.keys(ansiStyles$2)) {
	ansiStyles$2[key].closeRe = new RegExp(escapeStringRegexp$2(ansiStyles$2[key].close), 'g');

	styles[key] = {
		get() {
			const codes = ansiStyles$2[key];
			return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
		}
	};
}

styles.visible = {
	get() {
		return build.call(this, this._styles || [], true, 'visible');
	}
};

ansiStyles$2.color.closeRe = new RegExp(escapeStringRegexp$2(ansiStyles$2.color.close), 'g');
for (const model of Object.keys(ansiStyles$2.color.ansi)) {
	if (skipModels.has(model)) {
		continue;
	}

	styles[model] = {
		get() {
			const level = this.level;
			return function () {
				const open = ansiStyles$2.color[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles$2.color.close,
					closeRe: ansiStyles$2.color.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			};
		}
	};
}

ansiStyles$2.bgColor.closeRe = new RegExp(escapeStringRegexp$2(ansiStyles$2.bgColor.close), 'g');
for (const model of Object.keys(ansiStyles$2.bgColor.ansi)) {
	if (skipModels.has(model)) {
		continue;
	}

	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const level = this.level;
			return function () {
				const open = ansiStyles$2.bgColor[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles$2.bgColor.close,
					closeRe: ansiStyles$2.bgColor.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, styles);

function build(_styles, _empty, key) {
	const builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder._empty = _empty;

	const self = this;

	Object.defineProperty(builder, 'level', {
		enumerable: true,
		get() {
			return self.level;
		},
		set(level) {
			self.level = level;
		}
	});

	Object.defineProperty(builder, 'enabled', {
		enumerable: true,
		get() {
			return self.enabled;
		},
		set(enabled) {
			self.enabled = enabled;
		}
	});

	// See below for fix regarding invisible grey/dim combination on Windows
	builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';

	// `__proto__` is used because we must return a function, but there is
	// no way to create a function with a different prototype
	builder.__proto__ = proto; // eslint-disable-line no-proto

	return builder;
}

function applyStyle() {
	// Support varags, but simply cast to string in case there's only one arg
	const args = arguments;
	const argsLen = args.length;
	let str = String(arguments[0]);

	if (argsLen === 0) {
		return '';
	}

	if (argsLen > 1) {
		// Don't slice `arguments`, it prevents V8 optimizations
		for (let a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || this.level <= 0 || !str) {
		return this._empty ? '' : str;
	}

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	const originalDim = ansiStyles$2.dim.open;
	if (isSimpleWindowsTerm && this.hasGrey) {
		ansiStyles$2.dim.open = '';
	}

	for (const code of this._styles.slice().reverse()) {
		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;

		// Close the styling before a linebreak and reopen
		// after next line to fix a bleed issue on macOS
		// https://github.com/chalk/chalk/pull/92
		str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
	}

	// Reset the original `dim` if we changed it to work around the Windows dimmed gray issue
	ansiStyles$2.dim.open = originalDim;

	return str;
}

function chalkTag(chalk, strings) {
	if (!Array.isArray(strings)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return [].slice.call(arguments, 1).join(' ');
	}

	const args = [].slice.call(arguments, 2);
	const parts = [strings.raw[0]];

	for (let i = 1; i < strings.length; i++) {
		parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
		parts.push(String(strings.raw[i]));
	}

	return template(chalk, parts.join(''));
}

Object.defineProperties(Chalk.prototype, styles);

module.exports = Chalk(); // eslint-disable-line new-cap
module.exports.supportsColor = stdoutColor;
module.exports.default = module.exports; // For TypeScript
});
var chalk_1 = chalk.supportsColor;

var absolutePath = /^(?:\/|(?:[A-Za-z]:)?[\\|/])/;
function isAbsolute(path$$1) {
    return absolutePath.test(path$$1);
}

var jsExts = ['.js', '.mjs'];
function nameWithoutExtension(name) {
    for (var _i = 0, jsExts_1 = jsExts; _i < jsExts_1.length; _i++) {
        var ext = jsExts_1[_i];
        if (name.endsWith(ext))
            return name.substr(0, name.length - ext.length);
    }
    return name;
}
function relativeId(id) {
    if (typeof process === 'undefined' || !isAbsolute(id))
        return id;
    return path.relative(process.cwd(), id);
}

if (!chalk.supportsColor)
    chalk.enabled = false;
// log to stderr to keep `rollup main.js > bundle.js` from breaking
var stderr = console.error.bind(console); // eslint-disable-line no-console
function handleError(err, recover) {
    if (recover === void 0) { recover = false; }
    var description = err.message || err;
    if (err.name)
        description = err.name + ": " + description;
    var message = (err.plugin
        ? "(" + err.plugin + " plugin) " + description
        : description) || err;
    stderr(chalk.bold.red("[!] " + chalk.bold(message.toString())));
    // TODO should this be "err.url || (err.file && err.loc.file) || err.id"?
    if (err.url) {
        stderr(chalk.cyan(err.url));
    }
    if (err.loc) {
        stderr(relativeId(err.loc.file || err.id) + " (" + err.loc.line + ":" + err.loc.column + ")");
    }
    else if (err.id) {
        stderr(relativeId(err.id));
    }
    if (err.frame) {
        stderr(chalk.dim(err.frame));
    }
    else if (err.stack) {
        stderr(chalk.dim(err.stack));
    }
    stderr('');
    if (!recover)
        process.exit(1);
}

function ensureArray(thing) {
    if (Array.isArray(thing))
        return thing;
    if (thing == undefined)
        return [];
    return [thing];
}

function deprecateOptions(options, deprecateConfig) {
    var deprecations = [];
    if (deprecateConfig.input)
        deprecateInputOptions();
    if (deprecateConfig.output)
        deprecateOutputOptions();
    return deprecations;
    function deprecateInputOptions() {
        if (!options.input && options.entry)
            deprecate('entry', 'input');
        if (options.dest)
            deprecateToOutputOption('dest', 'file');
        if (options.moduleName)
            deprecateToOutputOption('moduleName', 'name');
        if (options.name)
            deprecateToOutputOption('name', 'name');
        if (options.extend)
            deprecateToOutputOption('extend', 'extend');
        if (options.globals)
            deprecateToOutputOption('globals', 'globals');
        if (options.indent)
            deprecateToOutputOption('indent', 'indent');
        if (options.noConflict)
            deprecateToOutputOption('noConflict', 'noConflict');
        if (options.paths)
            deprecateToOutputOption('paths', 'paths');
        if (options.sourcemap)
            deprecateToOutputOption('sourcemap', 'sourcemap');
        if (options.sourceMap)
            deprecateToOutputOption('sourceMap', 'sourcemap');
        if (options.sourceMapFile)
            deprecateToOutputOption('sourceMapFile', 'sourcemapFile');
        if (options.useStrict)
            deprecateToOutputOption('useStrict', 'strict');
        if (options.strict)
            deprecateToOutputOption('strict', 'strict');
        if (options.format)
            deprecateToOutputOption('format', 'format');
        if (options.banner)
            deprecateToOutputOption('banner', 'banner');
        if (options.footer)
            deprecateToOutputOption('footer', 'footer');
        if (options.intro)
            deprecateToOutputOption('intro', 'intro');
        if (options.outro)
            deprecateToOutputOption('outro', 'outro');
        if (options.interop)
            deprecateToOutputOption('interop', 'interop');
        if (options.freeze)
            deprecateToOutputOption('freeze', 'freeze');
        if (options.exports)
            deprecateToOutputOption('exports', 'exports');
        if (options.targets) {
            deprecations.push({ old: 'targets', new: 'output' });
            // as targets is an array and we need to merge other output options
            // like sourcemap etc.
            options.output = options.targets.map(function (target) {
                return Object.assign({}, target, options.output);
            });
            delete options.targets;
            var deprecatedDest_1 = false;
            options.output.forEach(function (outputEntry) {
                if (outputEntry.dest) {
                    if (!deprecatedDest_1) {
                        deprecations.push({ old: 'targets.dest', new: 'output.file' });
                        deprecatedDest_1 = true;
                    }
                    outputEntry.file = outputEntry.dest;
                    delete outputEntry.dest;
                }
            });
        }
        if (options.pureExternalModules) {
            deprecations.push({
                old: 'pureExternalModules',
                new: 'treeshake.pureExternalModules'
            });
            if (options.treeshake === undefined) {
                options.treeshake = {};
            }
            if (options.treeshake) {
                options.treeshake.pureExternalModules = options.pureExternalModules;
            }
            delete options.pureExternalModules;
        }
    }
    function deprecateOutputOptions() {
        if (options.output && options.output.moduleId) {
            options.output.amd = { id: options.moduleId };
            deprecations.push({ old: 'moduleId', new: 'amd' });
            delete options.output.moduleId;
        }
    }
    function deprecate(oldOption, newOption) {
        deprecations.push({ new: newOption, old: oldOption });
        if (!(newOption in options)) {
            options[newOption] = options[oldOption];
        }
        delete options[oldOption];
    }
    function deprecateToOutputOption(oldOption, newOption) {
        deprecations.push({ new: "output." + newOption, old: oldOption });
        options.output = options.output || {};
        if (!(newOption in options.output)) {
            options.output[newOption] = options[oldOption];
        }
        delete options[oldOption];
    }
}

var createGetOption = function (config, command) { return function (name, defaultValue) {
    return command[name] !== undefined
        ? command[name]
        : config[name] !== undefined ? config[name] : defaultValue;
}; };
var normalizeObjectOptionValue = function (optionValue) {
    if (!optionValue) {
        return optionValue;
    }
    if (typeof optionValue !== 'object') {
        return {};
    }
    return optionValue;
};
var getObjectOption = function (config, command, name) {
    var commandOption = normalizeObjectOptionValue(command[name]);
    var configOption = normalizeObjectOptionValue(config[name]);
    if (commandOption !== undefined) {
        return commandOption && configOption
            ? Object.assign({}, configOption, commandOption)
            : commandOption;
    }
    return configOption;
};
var defaultOnWarn = function (warning) {
    if (typeof warning === 'string') {
        console.warn(warning); // eslint-disable-line no-console
    }
    else {
        console.warn(warning.message); // eslint-disable-line no-console
    }
};
var getOnWarn = function (config, command, defaultOnWarnHandler) {
    if (defaultOnWarnHandler === void 0) { defaultOnWarnHandler = defaultOnWarn; }
    return command.silent
        ? function () { }
        : config.onwarn
            ? function (warning) { return config.onwarn(warning, defaultOnWarnHandler); }
            : defaultOnWarnHandler;
};
var getExternal = function (config, command) {
    var configExternal = config.external;
    return typeof configExternal === 'function'
        ? function (id) {
            var rest = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                rest[_i - 1] = arguments[_i];
            }
            return configExternal.apply(void 0, [id].concat(rest)) || command.external.indexOf(id) !== -1;
        }
        : (configExternal || []).concat(command.external);
};
var commandAliases = {
    c: 'config',
    e: 'external',
    f: 'format',
    g: 'globals',
    h: 'help',
    i: 'input',
    l: 'legacy',
    m: 'sourcemap',
    n: 'name',
    o: 'file',
    v: 'version',
    w: 'watch'
};
function mergeOptions(_a) {
    var _b = _a.config, config = _b === void 0 ? {} : _b, _c = _a.command, rawCommandOptions = _c === void 0 ? {} : _c, deprecateConfig = _a.deprecateConfig, defaultOnWarnHandler = _a.defaultOnWarnHandler;
    var deprecations = deprecate(config, rawCommandOptions, deprecateConfig);
    var command = getCommandOptions(rawCommandOptions);
    var inputOptions = getInputOptions(config, command, defaultOnWarnHandler);
    if (command.output) {
        Object.assign(command, command.output);
    }
    var normalizedOutputOptions = ensureArray(config.output);
    if (normalizedOutputOptions.length === 0)
        normalizedOutputOptions.push({});
    var outputOptions = normalizedOutputOptions.map(function (singleOutputOptions) {
        return getOutputOptions(singleOutputOptions, command);
    });
    var unknownOptionErrors = [];
    var validInputOptions = Object.keys(inputOptions);
    addUnknownOptionErrors(unknownOptionErrors, Object.keys(config), validInputOptions, 'input option', /^output$/);
    var validOutputOptions = Object.keys(outputOptions[0]);
    addUnknownOptionErrors(unknownOptionErrors, outputOptions.reduce(function (allKeys, options) { return allKeys.concat(Object.keys(options)); }, []), validOutputOptions, 'output option');
    addUnknownOptionErrors(unknownOptionErrors, Object.keys(command), validInputOptions.concat(validOutputOptions, Object.keys(commandAliases), 'config', 'environment', 'silent'), 'CLI flag', /^_|output|(config.*)$/);
    return {
        inputOptions: inputOptions,
        outputOptions: outputOptions,
        deprecations: deprecations,
        optionError: unknownOptionErrors.length > 0 ? unknownOptionErrors.join('\n') : null
    };
}
function addUnknownOptionErrors(errors, options, validOptions, optionType, ignoredKeys) {
    if (ignoredKeys === void 0) { ignoredKeys = /$./; }
    var unknownOptions = options.filter(function (key) { return validOptions.indexOf(key) === -1 && !ignoredKeys.test(key); });
    if (unknownOptions.length > 0)
        errors.push("Unknown " + optionType + ": " + unknownOptions.join(', ') + ". Allowed options: " + validOptions.sort().join(', '));
}
function getCommandOptions(rawCommandOptions) {
    var command = Object.assign({}, rawCommandOptions);
    command.external = (rawCommandOptions.external || '').split(',');
    if (rawCommandOptions.globals) {
        command.globals = Object.create(null);
        rawCommandOptions.globals.split(',').forEach(function (str) {
            var names = str.split(':');
            command.globals[names[0]] = names[1];
            // Add missing Module IDs to external.
            if (command.external.indexOf(names[0]) === -1) {
                command.external.push(names[0]);
            }
        });
    }
    return command;
}
function getInputOptions(config, command, defaultOnWarnHandler) {
    if (command === void 0) { command = {}; }
    var getOption = createGetOption(config, command);
    var inputOptions = {
        acorn: config.acorn,
        acornInjectPlugins: config.acornInjectPlugins,
        cache: getOption('cache'),
        context: config.context,
        experimentalCodeSplitting: getOption('experimentalCodeSplitting'),
        experimentalDynamicImport: getOption('experimentalDynamicImport'),
        experimentalPreserveModules: getOption('experimentalPreserveModules'),
        external: getExternal(config, command),
        input: getOption('input'),
        manualChunks: getOption('manualChunks'),
        chunkGroupingSize: getOption('chunkGroupingSize', 5000),
        optimizeChunks: getOption('optimizeChunks'),
        moduleContext: config.moduleContext,
        onwarn: getOnWarn(config, command, defaultOnWarnHandler),
        perf: getOption('perf', false),
        plugins: config.plugins,
        preferConst: getOption('preferConst'),
        preserveSymlinks: getOption('preserveSymlinks'),
        treeshake: getObjectOption(config, command, 'treeshake'),
        watch: config.watch
    };
    // legacy to make sure certain plugins still work
    if (Array.isArray(inputOptions.input)) {
        inputOptions.entry = inputOptions.input[0];
    }
    else if (typeof inputOptions.input === 'object') {
        for (var name in inputOptions.input) {
            inputOptions.entry = inputOptions.input[name];
            break;
        }
    }
    else {
        inputOptions.entry = inputOptions.input;
    }
    return inputOptions;
}
function getOutputOptions(config, command) {
    if (command === void 0) { command = {}; }
    var getOption = createGetOption(config, command);
    return {
        amd: Object.assign({}, config.amd, command.amd),
        banner: getOption('banner'),
        dir: getOption('dir'),
        chunkNames: getOption('chunkNames'),
        entryNames: getOption('entryNames'),
        exports: getOption('exports'),
        extend: getOption('extend'),
        file: getOption('file'),
        footer: getOption('footer'),
        format: getOption('format'),
        freeze: getOption('freeze'),
        globals: getOption('globals'),
        indent: getOption('indent', true),
        interop: getOption('interop', true),
        intro: getOption('intro'),
        legacy: getOption('legacy', false),
        name: getOption('name'),
        namespaceToStringTag: getOption('namespaceToStringTag'),
        noConflict: getOption('noConflict'),
        outro: getOption('outro'),
        paths: getOption('paths'),
        sourcemap: getOption('sourcemap'),
        sourcemapFile: getOption('sourcemapFile'),
        strict: getOption('strict', true)
    };
}
function deprecate(config, command, deprecateConfig) {
    if (command === void 0) { command = {}; }
    if (deprecateConfig === void 0) { deprecateConfig = { input: true, output: true }; }
    var deprecations = [];
    // CLI
    if (command.id) {
        deprecations.push({
            old: '-u/--id',
            new: '--amd.id'
        });
        (command.amd || (command.amd = {})).id = command.id;
    }
    if (typeof command.output === 'string') {
        deprecations.push({
            old: '--output',
            new: '--file'
        });
        command.output = { file: command.output };
    }
    if (command.d) {
        deprecations.push({
            old: '-d',
            new: '--indent'
        });
        command.indent = command.d;
    }
    // config file
    deprecations.push.apply(deprecations, deprecateOptions(config, deprecateConfig));
    return deprecations;
}

function batchWarnings() {
    var allWarnings = new Map();
    var count = 0;
    return {
        get count() {
            return count;
        },
        add: function (warning) {
            if (typeof warning === 'string') {
                warning = { code: 'UNKNOWN', message: warning };
            }
            if (warning.code in immediateHandlers) {
                immediateHandlers[warning.code](warning);
                return;
            }
            if (!allWarnings.has(warning.code))
                allWarnings.set(warning.code, []);
            allWarnings.get(warning.code).push(warning);
            count += 1;
        },
        flush: function () {
            if (count === 0)
                return;
            var codes = Array.from(allWarnings.keys()).sort(function (a, b) {
                if (deferredHandlers[a] && deferredHandlers[b]) {
                    return deferredHandlers[a].priority - deferredHandlers[b].priority;
                }
                if (deferredHandlers[a])
                    return -1;
                if (deferredHandlers[b])
                    return 1;
                return allWarnings.get(b).length - allWarnings.get(a).length;
            });
            codes.forEach(function (code) {
                var handler = deferredHandlers[code];
                var warnings = allWarnings.get(code);
                if (handler) {
                    handler.fn(warnings);
                }
                else {
                    warnings.forEach(function (warning) {
                        stderr(chalk.bold.yellow('(!)') + " " + chalk.bold.yellow(warning.message));
                        if (warning.url)
                            info(warning.url);
                        var id = (warning.loc && warning.loc.file) || warning.id;
                        if (id) {
                            var loc = warning.loc
                                ? relativeId(id) + ": (" + warning.loc.line + ":" + warning.loc.column + ")"
                                : relativeId(id);
                            stderr(chalk.bold(relativeId(loc)));
                        }
                        if (warning.frame)
                            info(warning.frame);
                    });
                }
            });
            allWarnings = new Map();
            count = 0;
        }
    };
}
var immediateHandlers = {
    UNKNOWN_OPTION: function (warning) {
        title("You have passed an unrecognized option");
        stderr(warning.message);
    },
    DEPRECATED_OPTIONS: function (warning) {
        title("Some options have been renamed");
        info("https://gist.github.com/Rich-Harris/d472c50732dab03efeb37472b08a3f32");
        warning.deprecations.forEach(function (option) {
            stderr(chalk.bold(option.old) + " is now " + option.new);
        });
    },
    MISSING_NODE_BUILTINS: function (warning) {
        title("Missing shims for Node.js built-ins");
        var detail = warning.modules.length === 1
            ? "'" + warning.modules[0] + "'"
            : warning.modules
                .slice(0, -1)
                .map(function (name) { return "'" + name + "'"; })
                .join(', ') + " and '" + warning.modules.slice(-1) + "'";
        stderr("Creating a browser bundle that depends on " + detail + ". You might need to include https://www.npmjs.com/package/rollup-plugin-node-builtins");
    },
    MIXED_EXPORTS: function () {
        title('Mixing named and default exports');
        stderr("Consumers of your bundle will have to use bundle['default'] to access the default export, which may not be what you want. Use `output.exports: 'named'` to disable this warning");
    },
    EMPTY_BUNDLE: function () {
        title("Generated an empty bundle");
    }
};
// TODO select sensible priorities
var deferredHandlers = {
    UNUSED_EXTERNAL_IMPORT: {
        priority: 1,
        fn: function (warnings) {
            title('Unused external imports');
            warnings.forEach(function (warning) {
                stderr(warning.names + " imported from external module '" + warning.source + "' but never used");
            });
        }
    },
    UNRESOLVED_IMPORT: {
        priority: 1,
        fn: function (warnings) {
            title('Unresolved dependencies');
            info('https://github.com/rollup/rollup/wiki/Troubleshooting#treating-module-as-external-dependency');
            var dependencies = new Map();
            warnings.forEach(function (warning) {
                if (!dependencies.has(warning.source))
                    dependencies.set(warning.source, []);
                dependencies.get(warning.source).push(warning.importer);
            });
            Array.from(dependencies.keys()).forEach(function (dependency) {
                var importers = dependencies.get(dependency);
                stderr(chalk.bold(dependency) + " (imported by " + importers.join(', ') + ")");
            });
        }
    },
    MISSING_EXPORT: {
        priority: 1,
        fn: function (warnings) {
            title('Missing exports');
            info('https://github.com/rollup/rollup/wiki/Troubleshooting#name-is-not-exported-by-module');
            warnings.forEach(function (warning) {
                stderr(chalk.bold(warning.importer));
                stderr(warning.missing + " is not exported by " + warning.exporter);
                stderr(chalk.grey(warning.frame));
            });
        }
    },
    THIS_IS_UNDEFINED: {
        priority: 1,
        fn: function (warnings) {
            title('`this` has been rewritten to `undefined`');
            info('https://github.com/rollup/rollup/wiki/Troubleshooting#this-is-undefined');
            showTruncatedWarnings(warnings);
        }
    },
    EVAL: {
        priority: 1,
        fn: function (warnings) {
            title('Use of eval is strongly discouraged');
            info('https://github.com/rollup/rollup/wiki/Troubleshooting#avoiding-eval');
            showTruncatedWarnings(warnings);
        }
    },
    NON_EXISTENT_EXPORT: {
        priority: 1,
        fn: function (warnings) {
            title("Import of non-existent " + (warnings.length > 1 ? 'exports' : 'export'));
            showTruncatedWarnings(warnings);
        }
    },
    NAMESPACE_CONFLICT: {
        priority: 1,
        fn: function (warnings) {
            title("Conflicting re-exports");
            warnings.forEach(function (warning) {
                stderr(chalk.bold(relativeId(warning.reexporter)) + " re-exports '" + warning.name + "' from both " + relativeId(warning.sources[0]) + " and " + relativeId(warning.sources[1]) + " (will be ignored)");
            });
        }
    },
    MISSING_GLOBAL_NAME: {
        priority: 1,
        fn: function (warnings) {
            title("Missing global variable " + (warnings.length > 1 ? 'names' : 'name'));
            stderr("Use output.globals to specify browser global variable names corresponding to external modules");
            warnings.forEach(function (warning) {
                stderr(chalk.bold(warning.source) + " (guessing '" + warning.guess + "')");
            });
        }
    },
    SOURCEMAP_BROKEN: {
        priority: 1,
        fn: function (warnings) {
            title("Broken sourcemap");
            info('https://github.com/rollup/rollup/wiki/Troubleshooting#sourcemap-is-likely-to-be-incorrect');
            var plugins = Array.from(new Set(warnings.map(function (w) { return w.plugin; }).filter(Boolean)));
            var detail = plugins.length === 0
                ? ''
                : plugins.length > 1
                    ? " (such as " + plugins
                        .slice(0, -1)
                        .map(function (p) { return "'" + p + "'"; })
                        .join(', ') + " and '" + plugins.slice(-1) + "')"
                    : " (such as '" + plugins[0] + "')";
            stderr("Plugins that transform code" + detail + " should generate accompanying sourcemaps");
        }
    },
    PLUGIN_WARNING: {
        priority: 1,
        fn: function (warnings) {
            var nestedByPlugin = nest(warnings, 'plugin');
            nestedByPlugin.forEach(function (_a) {
                var plugin = _a.key, items = _a.items;
                var nestedByMessage = nest(items, 'message');
                var lastUrl;
                nestedByMessage.forEach(function (_a) {
                    var message = _a.key, items = _a.items;
                    title(plugin + " plugin: " + message);
                    items.forEach(function (warning) {
                        if (warning.url !== lastUrl)
                            info((lastUrl = warning.url));
                        var loc = warning.loc
                            ? relativeId(warning.id) + ": (" + warning.loc.line + ":" + warning.loc.column + ")"
                            : relativeId(warning.id);
                        stderr(chalk.bold(relativeId(loc)));
                        if (warning.frame)
                            info(warning.frame);
                    });
                });
            });
        }
    }
};
function title(str) {
    stderr(chalk.bold.yellow('(!)') + " " + chalk.bold.yellow(str));
}
function info(url) {
    stderr(chalk.grey(url));
}
function nest(array, prop) {
    var nested = [];
    var lookup = new Map();
    array.forEach(function (item) {
        var key = item[prop];
        if (!lookup.has(key)) {
            lookup.set(key, {
                key: key,
                items: []
            });
            nested.push(lookup.get(key));
        }
        lookup.get(key).items.push(item);
    });
    return nested;
}
function showTruncatedWarnings(warnings) {
    var nestedByModule = nest(warnings, 'id');
    var sliced = nestedByModule.length > 5 ? nestedByModule.slice(0, 3) : nestedByModule;
    sliced.forEach(function (_a) {
        var id = _a.key, items = _a.items;
        stderr(chalk.bold(relativeId(id)));
        stderr(chalk.grey(items[0].frame));
        if (items.length > 1) {
            stderr("...and " + (items.length - 1) + " other " + (items.length > 2 ? 'occurrences' : 'occurrence'));
        }
    });
    if (nestedByModule.length > sliced.length) {
        stderr("\n...and " + (nestedByModule.length - sliced.length) + " other files");
    }
}

function loadConfigFile(configFile, commandOptions) {
    if (commandOptions === void 0) { commandOptions = {}; }
    var silent = commandOptions.silent || false;
    var warnings = batchWarnings();
    return rollup__default
        .rollup({
        input: configFile,
        external: function (id) {
            return (id[0] !== '.' && !path__default.isAbsolute(id)) || id.slice(-5, id.length) === '.json';
        },
        onwarn: warnings.add
    })
        .then(function (bundle) {
        if (!silent && warnings.count > 0) {
            stderr(chalk.bold("loaded " + relativeId(configFile) + " with warnings"));
            warnings.flush();
        }
        return bundle.generate({
            format: 'cjs'
        });
    })
        .then(function (_a) {
        var code = _a.code;
        // temporarily override require
        var defaultLoader = require.extensions['.js'];
        require.extensions['.js'] = function (module, filename) {
            if (filename === configFile) {
                module._compile(code, filename);
            }
            else {
                defaultLoader(module, filename);
            }
        };
        delete require.cache[configFile];
        return Promise.resolve(require(configFile))
            .then(function (configFileContent) {
            if (typeof configFileContent === 'function') {
                return configFileContent(commandOptions);
            }
            return configFileContent;
        })
            .then(function (configs) {
            if (Object.keys(configs).length === 0) {
                handleError({
                    code: 'MISSING_CONFIG',
                    message: 'Config file must export an options object, or an array of options objects',
                    url: 'https://rollupjs.org/#using-config-files'
                });
            }
            require.extensions['.js'] = defaultLoader;
            return Array.isArray(configs) ? configs : [configs];
        });
    });
}

function sequence(array, fn) {
    var results = [];
    var promise = Promise.resolve();
    function next(member, i) {
        return fn(member).then(function (value) { return (results[i] = value); });
    }
    var _loop_1 = function (i) {
        promise = promise.then(function () { return next(array[i], i); });
    };
    for (var i = 0; i < array.length; i += 1) {
        _loop_1(i);
    }
    return promise.then(function () { return results; });
}

var parseMs = function (ms) {
	if (typeof ms !== 'number') {
		throw new TypeError('Expected a number');
	}

	var roundTowardZero = ms > 0 ? Math.floor : Math.ceil;

	return {
		days: roundTowardZero(ms / 86400000),
		hours: roundTowardZero(ms / 3600000) % 24,
		minutes: roundTowardZero(ms / 60000) % 60,
		seconds: roundTowardZero(ms / 1000) % 60,
		milliseconds: roundTowardZero(ms) % 1000
	};
};

var parseMs$1 = /*#__PURE__*/Object.freeze({
    default: parseMs,
    __moduleExports: parseMs
});

var addendum = "addenda";
var aircraft = "aircraft";
var alga = "algae";
var alumna = "alumnae";
var alumnus = "alumni";
var amoeba = "amoebae";
var analysis = "analyses";
var antenna = "antennae";
var antithesis = "antitheses";
var apex = "apices";
var appendix = "appendices";
var automaton = "automata";
var axis = "axes";
var bacillus = "bacilli";
var bacterium = "bacteria";
var barracks = "barracks";
var basis = "bases";
var beau = "beaux";
var bison = "bison";
var buffalo = "buffalo";
var bureau = "bureaus";
var cactus = "cacti";
var calf = "calves";
var carp = "carp";
var census = "censuses";
var chassis = "chassis";
var cherub = "cherubim";
var child = "children";
var cod = "cod";
var codex = "codices";
var concerto = "concerti";
var corpus = "corpora";
var crisis = "crises";
var criterion = "criteria";
var curriculum = "curricula";
var datum = "data";
var deer = "deer";
var diagnosis = "diagnoses";
var die = "dice";
var dwarf = "dwarfs";
var echo = "echoes";
var elf = "elves";
var elk = "elk";
var ellipsis = "ellipses";
var embargo = "embargoes";
var emphasis = "emphases";
var erratum = "errata";
var fez = "fezes";
var firmware = "firmware";
var fish = "fish";
var focus = "foci";
var foot = "feet";
var formula = "formulae";
var fungus = "fungi";
var gallows = "gallows";
var genus = "genera";
var goose = "geese";
var graffito = "graffiti";
var grouse = "grouse";
var half = "halves";
var hero = "heroes";
var hoof = "hooves";
var hovercraft = "hovercraft";
var hypothesis = "hypotheses";
var index = "indices";
var kakapo = "kakapo";
var knife = "knives";
var larva = "larvae";
var leaf = "leaves";
var libretto = "libretti";
var life = "lives";
var loaf = "loaves";
var locus = "loci";
var louse = "lice";
var man = "men";
var matrix = "matrices";
var means = "means";
var medium = "media";
var memorandum = "memoranda";
var millennium = "millennia";
var minutia = "minutiae";
var moose = "moose";
var mouse = "mice";
var nebula = "nebulae";
var nemesis = "nemeses";
var neurosis = "neuroses";
var news = "news";
var nucleus = "nuclei";
var oasis = "oases";
var offspring = "offspring";
var opus = "opera";
var ovum = "ova";
var ox = "oxen";
var paralysis = "paralyses";
var parenthesis = "parentheses";
var person = "people";
var phenomenon = "phenomena";
var phylum = "phyla";
var pike = "pike";
var polyhedron = "polyhedra";
var potato = "potatoes";
var prognosis = "prognoses";
var quiz = "quizzes";
var radius = "radii";
var referendum = "referenda";
var salmon = "salmon";
var scarf = "scarves";
var self$1 = "selves";
var series = "series";
var sheep = "sheep";
var shelf = "shelves";
var shrimp = "shrimp";
var spacecraft = "spacecraft";
var species = "species";
var spectrum = "spectra";
var squid = "squid";
var stimulus = "stimuli";
var stratum = "strata";
var swine = "swine";
var syllabus = "syllabi";
var symposium = "symposia";
var synopsis = "synopses";
var synthesis = "syntheses";
var tableau = "tableaus";
var that = "those";
var thesis = "theses";
var thief = "thieves";
var tomato = "tomatoes";
var tooth = "teeth";
var trout = "trout";
var tuna = "tuna";
var vertebra = "vertebrae";
var vertex = "vertices";
var veto = "vetoes";
var vita = "vitae";
var vortex = "vortices";
var watercraft = "watercraft";
var wharf = "wharves";
var wife = "wives";
var wolf = "wolves";
var woman = "women";
var irregularPlurals = {
	addendum: addendum,
	aircraft: aircraft,
	alga: alga,
	alumna: alumna,
	alumnus: alumnus,
	amoeba: amoeba,
	analysis: analysis,
	antenna: antenna,
	antithesis: antithesis,
	apex: apex,
	appendix: appendix,
	automaton: automaton,
	axis: axis,
	bacillus: bacillus,
	bacterium: bacterium,
	barracks: barracks,
	basis: basis,
	beau: beau,
	bison: bison,
	buffalo: buffalo,
	bureau: bureau,
	cactus: cactus,
	calf: calf,
	carp: carp,
	census: census,
	chassis: chassis,
	cherub: cherub,
	child: child,
	cod: cod,
	codex: codex,
	concerto: concerto,
	corpus: corpus,
	crisis: crisis,
	criterion: criterion,
	curriculum: curriculum,
	datum: datum,
	deer: deer,
	diagnosis: diagnosis,
	die: die,
	dwarf: dwarf,
	echo: echo,
	elf: elf,
	elk: elk,
	ellipsis: ellipsis,
	embargo: embargo,
	emphasis: emphasis,
	erratum: erratum,
	fez: fez,
	firmware: firmware,
	fish: fish,
	focus: focus,
	foot: foot,
	formula: formula,
	fungus: fungus,
	gallows: gallows,
	genus: genus,
	goose: goose,
	graffito: graffito,
	grouse: grouse,
	half: half,
	hero: hero,
	hoof: hoof,
	hovercraft: hovercraft,
	hypothesis: hypothesis,
	index: index,
	kakapo: kakapo,
	knife: knife,
	larva: larva,
	leaf: leaf,
	libretto: libretto,
	life: life,
	loaf: loaf,
	locus: locus,
	louse: louse,
	man: man,
	matrix: matrix,
	means: means,
	medium: medium,
	memorandum: memorandum,
	millennium: millennium,
	minutia: minutia,
	moose: moose,
	mouse: mouse,
	nebula: nebula,
	nemesis: nemesis,
	neurosis: neurosis,
	news: news,
	nucleus: nucleus,
	oasis: oasis,
	offspring: offspring,
	opus: opus,
	ovum: ovum,
	ox: ox,
	paralysis: paralysis,
	parenthesis: parenthesis,
	person: person,
	phenomenon: phenomenon,
	phylum: phylum,
	pike: pike,
	polyhedron: polyhedron,
	potato: potato,
	prognosis: prognosis,
	quiz: quiz,
	radius: radius,
	referendum: referendum,
	salmon: salmon,
	scarf: scarf,
	self: self$1,
	series: series,
	sheep: sheep,
	shelf: shelf,
	shrimp: shrimp,
	spacecraft: spacecraft,
	species: species,
	spectrum: spectrum,
	squid: squid,
	stimulus: stimulus,
	stratum: stratum,
	swine: swine,
	syllabus: syllabus,
	symposium: symposium,
	synopsis: synopsis,
	synthesis: synthesis,
	tableau: tableau,
	that: that,
	thesis: thesis,
	thief: thief,
	tomato: tomato,
	tooth: tooth,
	trout: trout,
	tuna: tuna,
	vertebra: vertebra,
	vertex: vertex,
	veto: veto,
	vita: vita,
	vortex: vortex,
	watercraft: watercraft,
	wharf: wharf,
	wife: wife,
	wolf: wolf,
	woman: woman,
	"chÃ¢teau": "chÃ¢teaus",
	"faux pas": "faux pas",
	"this": "these"
};

var irregularPlurals$1 = /*#__PURE__*/Object.freeze({
    addendum: addendum,
    aircraft: aircraft,
    alga: alga,
    alumna: alumna,
    alumnus: alumnus,
    amoeba: amoeba,
    analysis: analysis,
    antenna: antenna,
    antithesis: antithesis,
    apex: apex,
    appendix: appendix,
    automaton: automaton,
    axis: axis,
    bacillus: bacillus,
    bacterium: bacterium,
    barracks: barracks,
    basis: basis,
    beau: beau,
    bison: bison,
    buffalo: buffalo,
    bureau: bureau,
    cactus: cactus,
    calf: calf,
    carp: carp,
    census: census,
    chassis: chassis,
    cherub: cherub,
    child: child,
    cod: cod,
    codex: codex,
    concerto: concerto,
    corpus: corpus,
    crisis: crisis,
    criterion: criterion,
    curriculum: curriculum,
    datum: datum,
    deer: deer,
    diagnosis: diagnosis,
    die: die,
    dwarf: dwarf,
    echo: echo,
    elf: elf,
    elk: elk,
    ellipsis: ellipsis,
    embargo: embargo,
    emphasis: emphasis,
    erratum: erratum,
    fez: fez,
    firmware: firmware,
    fish: fish,
    focus: focus,
    foot: foot,
    formula: formula,
    fungus: fungus,
    gallows: gallows,
    genus: genus,
    goose: goose,
    graffito: graffito,
    grouse: grouse,
    half: half,
    hero: hero,
    hoof: hoof,
    hovercraft: hovercraft,
    hypothesis: hypothesis,
    index: index,
    kakapo: kakapo,
    knife: knife,
    larva: larva,
    leaf: leaf,
    libretto: libretto,
    life: life,
    loaf: loaf,
    locus: locus,
    louse: louse,
    man: man,
    matrix: matrix,
    means: means,
    medium: medium,
    memorandum: memorandum,
    millennium: millennium,
    minutia: minutia,
    moose: moose,
    mouse: mouse,
    nebula: nebula,
    nemesis: nemesis,
    neurosis: neurosis,
    news: news,
    nucleus: nucleus,
    oasis: oasis,
    offspring: offspring,
    opus: opus,
    ovum: ovum,
    ox: ox,
    paralysis: paralysis,
    parenthesis: parenthesis,
    person: person,
    phenomenon: phenomenon,
    phylum: phylum,
    pike: pike,
    polyhedron: polyhedron,
    potato: potato,
    prognosis: prognosis,
    quiz: quiz,
    radius: radius,
    referendum: referendum,
    salmon: salmon,
    scarf: scarf,
    self: self$1,
    series: series,
    sheep: sheep,
    shelf: shelf,
    shrimp: shrimp,
    spacecraft: spacecraft,
    species: species,
    spectrum: spectrum,
    squid: squid,
    stimulus: stimulus,
    stratum: stratum,
    swine: swine,
    syllabus: syllabus,
    symposium: symposium,
    synopsis: synopsis,
    synthesis: synthesis,
    tableau: tableau,
    that: that,
    thesis: thesis,
    thief: thief,
    tomato: tomato,
    tooth: tooth,
    trout: trout,
    tuna: tuna,
    vertebra: vertebra,
    vertex: vertex,
    veto: veto,
    vita: vita,
    vortex: vortex,
    watercraft: watercraft,
    wharf: wharf,
    wife: wife,
    wolf: wolf,
    woman: woman,
    default: irregularPlurals
});

var irregularPlurals$2 = ( irregularPlurals$1 && irregularPlurals ) || irregularPlurals$1;

var plur = function (str, plural, count) {
	if (typeof plural === 'number') {
		count = plural;
	}

	if (str in irregularPlurals$2) {
		plural = irregularPlurals$2[str];
	} else if (typeof plural !== 'string') {
		plural = (str.replace(/(?:s|x|z|ch|sh)$/i, '$&e').replace(/([^aeiou])y$/i, '$1ie') + 's')
			.replace(/i?e?s$/i, function (m) {
				var isTailLowerCase = str.slice(-1) === str.slice(-1).toLowerCase();
				return isTailLowerCase ? m.toLowerCase() : m.toUpperCase();
			});
	}

	return count === 1 ? str : plural;
};

var plur$1 = /*#__PURE__*/Object.freeze({
    default: plur,
    __moduleExports: plur
});

var parseMs$2 = ( parseMs$1 && parseMs ) || parseMs$1;

var plur$2 = ( plur$1 && plur ) || plur$1;

var prettyMs = (ms, opts) => {
	if (!Number.isFinite(ms)) {
		throw new TypeError('Expected a finite number');
	}

	opts = opts || {};

	if (ms < 1000) {
		const msDecimalDigits = typeof opts.msDecimalDigits === 'number' ? opts.msDecimalDigits : 0;
		return (msDecimalDigits ? ms.toFixed(msDecimalDigits) : Math.ceil(ms)) + (opts.verbose ? ' ' + plur$2('millisecond', Math.ceil(ms)) : 'ms');
	}

	const ret = [];

	const add = (val, long, short, valStr) => {
		if (val === 0) {
			return;
		}

		const postfix = opts.verbose ? ' ' + plur$2(long, val) : short;

		ret.push((valStr || val) + postfix);
	};

	const parsed = parseMs$2(ms);

	add(Math.trunc(parsed.days / 365), 'year', 'y');
	add(parsed.days % 365, 'day', 'd');
	add(parsed.hours, 'hour', 'h');
	add(parsed.minutes, 'minute', 'm');

	if (opts.compact) {
		add(parsed.seconds, 'second', 's');
		return '~' + ret[0];
	}

	const sec = ms / 1000 % 60;
	const secDecimalDigits = typeof opts.secDecimalDigits === 'number' ? opts.secDecimalDigits : 1;
	const secFixed = sec.toFixed(secDecimalDigits);
	const secStr = opts.keepDecimalsOnWholeSeconds ? secFixed : secFixed.replace(/\.0+$/, '');
	add(sec, 'second', 's', secStr);

	return ret.join(' ');
};

function mapSequence(array, fn) {
    var results = [];
    var promise = Promise.resolve();
    function next(member, i) {
        return Promise.resolve(fn(member)).then(function (value) { return (results[i] = value); });
    }
    var _loop_1 = function (i) {
        promise = promise.then(function () { return next(array[i], i); });
    };
    for (var i = 0; i < array.length; i += 1) {
        _loop_1(i);
    }
    return promise.then(function () { return results; });
}

var SOURCEMAPPING_URL = 'sourceMa';
SOURCEMAPPING_URL += 'ppingURL';
var SOURCEMAPPING_URL$1 = SOURCEMAPPING_URL;

function printTimings(timings) {
    Object.keys(timings).forEach(function (label) {
        var color = chalk;
        if (label[0] === '#') {
            color = color.bold;
            if (label[1] !== '#') {
                color = color.underline;
            }
        }
        console.info(color(label + ": " + timings[label].toFixed(0) + "ms"));
    });
}

function build(inputOptions, outputOptions, warnings, silent) {
    if (silent === void 0) { silent = false; }
    var useStdout = outputOptions.length === 1 &&
        !outputOptions[0].file &&
        !outputOptions[0].dir &&
        inputOptions.input instanceof Array === false &&
        typeof inputOptions.input !== 'object';
    var start = Date.now();
    var files = useStdout ? ['stdout'] : outputOptions.map(function (t) { return relativeId(t.file || t.dir); });
    if (!silent) {
        var inputFiles = void 0;
        if (typeof inputOptions.input === 'string') {
            inputFiles = inputOptions.input;
        }
        else if (inputOptions.input instanceof Array) {
            inputFiles = inputOptions.input.join(', ');
        }
        else if (typeof inputOptions.input === 'object' && inputOptions.input !== null) {
            inputFiles = Object.keys(inputOptions.input)
                .map(function (name) { return inputOptions.input[name]; })
                .join(', ');
        }
        stderr(chalk.cyan("\n" + chalk.bold(inputFiles) + " \u2192 " + chalk.bold(files.join(', ')) + "..."));
    }
    return rollup.rollup(inputOptions)
        .then(function (bundle) {
        if (useStdout) {
            var output_1 = outputOptions[0];
            if (output_1.sourcemap && output_1.sourcemap !== 'inline') {
                handleError({
                    code: 'MISSING_OUTPUT_OPTION',
                    message: 'You must specify a --file (-o) option when creating a file with a sourcemap'
                });
            }
            return bundle.generate(output_1).then(function (_a) {
                var code = _a.code, map = _a.map;
                if (!code)
                    return;
                if (output_1.sourcemap === 'inline') {
                    code += "\n//# " + SOURCEMAPPING_URL$1 + "=" + map.toUrl() + "\n";
                }
                process.stdout.write(code);
            });
        }
        return mapSequence(outputOptions, function (output) { return bundle.write(output); }).then(function () { return bundle; });
    })
        .then(function (bundle) {
        warnings.flush();
        if (!silent)
            stderr(chalk.green("created " + chalk.bold(files.join(', ')) + " in " + chalk.bold(prettyMs(Date.now() - start))));
        if (bundle && bundle.getTimings) {
            printTimings(bundle.getTimings());
        }
    })
        .catch(handleError);
}

var signals = createCommonjsModule(function (module) {
// This is not the set of all possible signals.
//
// It IS, however, the set of all signals that trigger
// an exit on either Linux or BSD systems.  Linux is a
// superset of the signal names supported on BSD, and
// the unknown signals just fail to register, so we can
// catch that easily enough.
//
// Don't bother with SIGKILL.  It's uncatchable, which
// means that we can't fire any callbacks anyway.
//
// If a user does happen to register a handler on a non-
// fatal signal like SIGWINCH or something, and then
// exit, it'll end up firing `process.emit('exit')`, so
// the handler will be fired anyway.
//
// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
// artificially, inherently leave the process in a
// state from which it is not safe to try and enter JS
// listeners.
module.exports = [
  'SIGABRT',
  'SIGALRM',
  'SIGHUP',
  'SIGINT',
  'SIGTERM'
];

if (process.platform !== 'win32') {
  module.exports.push(
    'SIGVTALRM',
    'SIGXCPU',
    'SIGXFSZ',
    'SIGUSR2',
    'SIGTRAP',
    'SIGSYS',
    'SIGQUIT',
    'SIGIOT'
    // should detect profiler and enable/disable accordingly.
    // see #21
    // 'SIGPROF'
  );
}

if (process.platform === 'linux') {
  module.exports.push(
    'SIGIO',
    'SIGPOLL',
    'SIGPWR',
    'SIGSTKFLT',
    'SIGUNUSED'
  );
}
});

var signals$1 = /*#__PURE__*/Object.freeze({
    default: signals,
    __moduleExports: signals
});

var require$$0$1 = ( signals$1 && signals ) || signals$1;

// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.

var signals$2 = require$$0$1;

var EE = events;
/* istanbul ignore if */
if (typeof EE !== 'function') {
  EE = EE.EventEmitter;
}

var emitter;
if (process.__signal_exit_emitter__) {
  emitter = process.__signal_exit_emitter__;
} else {
  emitter = process.__signal_exit_emitter__ = new EE();
  emitter.count = 0;
  emitter.emitted = {};
}

// Because this emitter is a global, we have to check to see if a
// previous version of this library failed to enable infinite listeners.
// I know what you're about to say.  But literally everything about
// signal-exit is a compromise with evil.  Get used to it.
if (!emitter.infinite) {
  emitter.setMaxListeners(Infinity);
  emitter.infinite = true;
}

var signalExit = function (cb, opts) {
  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');

  if (loaded === false) {
    load();
  }

  var ev = 'exit';
  if (opts && opts.alwaysLast) {
    ev = 'afterexit';
  }

  var remove = function () {
    emitter.removeListener(ev, cb);
    if (emitter.listeners('exit').length === 0 &&
        emitter.listeners('afterexit').length === 0) {
      unload();
    }
  };
  emitter.on(ev, cb);

  return remove
};

var unload_1 = unload;
function unload () {
  if (!loaded) {
    return
  }
  loaded = false;

  signals$2.forEach(function (sig) {
    try {
      process.removeListener(sig, sigListeners[sig]);
    } catch (er) {}
  });
  process.emit = originalProcessEmit;
  process.reallyExit = originalProcessReallyExit;
  emitter.count -= 1;
}

function emit (event, code, signal) {
  if (emitter.emitted[event]) {
    return
  }
  emitter.emitted[event] = true;
  emitter.emit(event, code, signal);
}

// { <signal>: <listener fn>, ... }
var sigListeners = {};
signals$2.forEach(function (sig) {
  sigListeners[sig] = function listener () {
    // If there are no other listeners, an exit is coming!
    // Simplest way: remove us and then re-send the signal.
    // We know that this will kill the process, so we can
    // safely emit now.
    var listeners = process.listeners(sig);
    if (listeners.length === emitter.count) {
      unload();
      emit('exit', null, sig);
      /* istanbul ignore next */
      emit('afterexit', null, sig);
      /* istanbul ignore next */
      process.kill(process.pid, sig);
    }
  };
});

var signals_1 = function () {
  return signals$2
};

var load_1 = load;

var loaded = false;

function load () {
  if (loaded) {
    return
  }
  loaded = true;

  // This is the number of onSignalExit's that are in play.
  // It's important so that we can count the correct number of
  // listeners on signals, and don't wait for the other one to
  // handle it instead of us.
  emitter.count += 1;

  signals$2 = signals$2.filter(function (sig) {
    try {
      process.on(sig, sigListeners[sig]);
      return true
    } catch (er) {
      return false
    }
  });

  process.emit = processEmit;
  process.reallyExit = processReallyExit;
}

var originalProcessReallyExit = process.reallyExit;
function processReallyExit (code) {
  process.exitCode = code || 0;
  emit('exit', process.exitCode, null);
  /* istanbul ignore next */
  emit('afterexit', process.exitCode, null);
  /* istanbul ignore next */
  originalProcessReallyExit.call(process, process.exitCode);
}

var originalProcessEmit = process.emit;
function processEmit (ev, arg) {
  if (ev === 'exit') {
    if (arg !== undefined) {
      process.exitCode = arg;
    }
    var ret = originalProcessEmit.apply(this, arguments);
    emit('exit', process.exitCode, null);
    /* istanbul ignore next */
    emit('afterexit', process.exitCode, null);
    return ret
  } else {
    return originalProcessEmit.apply(this, arguments)
  }
}
signalExit.unload = unload_1;
signalExit.signals = signals_1;
signalExit.load = load_1;

var timeZone = date => {
	const offset = (date || new Date()).getTimezoneOffset();
	const absOffset = Math.abs(offset);
	const hours = Math.floor(absOffset / 60);
	const minutes = absOffset % 60;
	const minutesOut = minutes > 0 ? ':' + ('0' + minutes).slice(-2) : '';

	return (offset < 0 ? '+' : '-') + hours + minutesOut;
};

var timeZone$1 = /*#__PURE__*/Object.freeze({
    default: timeZone,
    __moduleExports: timeZone
});

var timeZone$2 = ( timeZone$1 && timeZone ) || timeZone$1;

var dateTime = options => {
	options = Object.assign({
		date: new Date(),
		local: true,
		showTimeZone: false,
		showMilliseconds: false
	}, options);

	let date = options.date;

	if (options.local) {
		// Offset the date so it will return the correct value when getting the ISO string
		date = new Date(date.getTime() - (date.getTimezoneOffset() * 60000));
	}

	let end = '';

	if (options.showTimeZone) {
		end = ' UTC' + (options.local ? timeZone$2(date) : '');
	}

	if (options.showMilliseconds && date.getUTCMilliseconds() > 0) {
		end = ` ${date.getUTCMilliseconds()}ms${end}`;
	}

	return date
		.toISOString()
		.replace(/T/, ' ')
		.replace(/\..+/, end);
};

var ansiEscapes = createCommonjsModule(function (module) {
const x = module.exports;
const ESC = '\u001B[';
const OSC = '\u001B]';
const BEL = '\u0007';
const SEP = ';';
const isTerminalApp = process.env.TERM_PROGRAM === 'Apple_Terminal';

x.cursorTo = (x, y) => {
	if (typeof x !== 'number') {
		throw new TypeError('The `x` argument is required');
	}

	if (typeof y !== 'number') {
		return ESC + (x + 1) + 'G';
	}

	return ESC + (y + 1) + ';' + (x + 1) + 'H';
};

x.cursorMove = (x, y) => {
	if (typeof x !== 'number') {
		throw new TypeError('The `x` argument is required');
	}

	let ret = '';

	if (x < 0) {
		ret += ESC + (-x) + 'D';
	} else if (x > 0) {
		ret += ESC + x + 'C';
	}

	if (y < 0) {
		ret += ESC + (-y) + 'A';
	} else if (y > 0) {
		ret += ESC + y + 'B';
	}

	return ret;
};

x.cursorUp = count => ESC + (typeof count === 'number' ? count : 1) + 'A';
x.cursorDown = count => ESC + (typeof count === 'number' ? count : 1) + 'B';
x.cursorForward = count => ESC + (typeof count === 'number' ? count : 1) + 'C';
x.cursorBackward = count => ESC + (typeof count === 'number' ? count : 1) + 'D';

x.cursorLeft = ESC + 'G';
x.cursorSavePosition = ESC + (isTerminalApp ? '7' : 's');
x.cursorRestorePosition = ESC + (isTerminalApp ? '8' : 'u');
x.cursorGetPosition = ESC + '6n';
x.cursorNextLine = ESC + 'E';
x.cursorPrevLine = ESC + 'F';
x.cursorHide = ESC + '?25l';
x.cursorShow = ESC + '?25h';

x.eraseLines = count => {
	let clear = '';

	for (let i = 0; i < count; i++) {
		clear += x.eraseLine + (i < count - 1 ? x.cursorUp() : '');
	}

	if (count) {
		clear += x.cursorLeft;
	}

	return clear;
};

x.eraseEndLine = ESC + 'K';
x.eraseStartLine = ESC + '1K';
x.eraseLine = ESC + '2K';
x.eraseDown = ESC + 'J';
x.eraseUp = ESC + '1J';
x.eraseScreen = ESC + '2J';
x.scrollUp = ESC + 'S';
x.scrollDown = ESC + 'T';

x.clearScreen = '\u001Bc';
x.beep = BEL;

x.link = (text, url) => {
	return [
		OSC,
		'8',
		SEP,
		SEP,
		url,
		BEL,
		text,
		OSC,
		'8',
		SEP,
		SEP,
		BEL
	].join('');
};

x.image = (buf, opts) => {
	opts = opts || {};

	let ret = OSC + '1337;File=inline=1';

	if (opts.width) {
		ret += `;width=${opts.width}`;
	}

	if (opts.height) {
		ret += `;height=${opts.height}`;
	}

	if (opts.preserveAspectRatio === false) {
		ret += ';preserveAspectRatio=0';
	}

	return ret + ':' + buf.toString('base64') + BEL;
};

x.iTerm = {};

x.iTerm.setCwd = cwd => OSC + '50;CurrentDir=' + (cwd || process.cwd()) + BEL;
});

var SHOW_ALTERNATE_SCREEN = '\u001B[?1049h';
var HIDE_ALTERNATE_SCREEN = '\u001B[?1049l';
var isWindows = process.platform === 'win32';
var isMintty = isWindows && !!(process.env.SHELL || process.env.TERM);
var isConEmuAnsiOn = (process.env.ConEmuANSI || '').toLowerCase() === 'on';
var supportsAnsi = !isWindows || isMintty || isConEmuAnsiOn;
function alternateScreen(enabled) {
    if (!enabled) {
        var needAnnounce_1 = true;
        return {
            open: function () { },
            close: function () { },
            reset: function (heading) {
                if (needAnnounce_1) {
                    stderr(heading);
                    needAnnounce_1 = false;
                }
            }
        };
    }
    return {
        open: function () {
            if (supportsAnsi) {
                process.stderr.write(SHOW_ALTERNATE_SCREEN);
            }
        },
        close: function () {
            if (supportsAnsi) {
                process.stderr.write(HIDE_ALTERNATE_SCREEN);
            }
        },
        reset: function (heading) {
            stderr("" + ansiEscapes.eraseScreen + ansiEscapes.cursorTo(0, 0) + heading);
        }
    };
}

function watch(configFile, configs, command, silent) {
    if (silent === void 0) { silent = false; }
    var isTTY = Boolean(process.stderr.isTTY);
    var screen = alternateScreen(isTTY);
    screen.open();
    var warnings = batchWarnings();
    var watcher;
    var configWatcher;
    function start(configs) {
        screen.reset(chalk.underline("rollup v" + rollup.VERSION));
        var screenWriter = screen.reset;
        configs = configs.map(function (options) {
            var merged = mergeOptions({
                config: options,
                command: command,
                defaultOnWarnHandler: warnings.add
            });
            var result = Object.assign({}, merged.inputOptions, {
                output: merged.outputOptions
            });
            if (merged.deprecations.length) {
                if (!result.watch)
                    result.watch = {};
                result.watch._deprecations = merged.deprecations;
            }
            if (merged.optionError)
                merged.inputOptions.onwarn({
                    message: merged.optionError,
                    code: 'UNKNOWN_OPTION'
                });
            if (merged.inputOptions.watch &&
                merged.inputOptions.watch.clearScreen === false) {
                screenWriter = stderr;
            }
            return result;
        });
        watcher = rollup.watch(configs);
        watcher.on('event', function (event) {
            switch (event.code) {
                case 'FATAL':
                    screen.close();
                    handleError(event.error, true);
                    process.exit(1);
                    break;
                case 'ERROR':
                    warnings.flush();
                    handleError(event.error, true);
                    break;
                case 'START':
                    screenWriter(chalk.underline("rollup v" + rollup.VERSION));
                    break;
                case 'BUNDLE_START':
                    if (!silent)
                        stderr(chalk.cyan("bundles " + chalk.bold(typeof event.input === 'string' ? event.input : event.input.join(', ')) + " \u2192 " + chalk.bold(event.output.map(relativeId).join(', ')) + "..."));
                    break;
                case 'BUNDLE_END':
                    warnings.flush();
                    if (!silent)
                        stderr(chalk.green("created " + chalk.bold(event.output.map(relativeId).join(', ')) + " in " + chalk.bold(prettyMs(event.duration))));
                    if (event.result && event.result.getTimings) {
                        printTimings(event.result.getTimings());
                    }
                    break;
                case 'END':
                    if (!silent && isTTY) {
                        stderr("\n[" + dateTime() + "] waiting for changes...");
                    }
            }
        });
    }
    // catch ctrl+c, kill, and uncaught errors
    var removeOnExit = signalExit(close);
    process.on('uncaughtException', close);
    // only listen to stdin if it is a pipe
    if (!process.stdin.isTTY) {
        process.stdin.on('end', close); // in case we ever support stdin!
        process.stdin.resume();
    }
    function close(err) {
        if (err) {
            console.error(err);
        }
        removeOnExit();
        process.removeListener('uncaughtException', close);
        // removing a non-existent listener is a no-op
        process.stdin.removeListener('end', close);
        screen.close();
        if (watcher)
            watcher.close();
        if (configWatcher)
            configWatcher.close();
        if (err) {
            process.exit(1);
        }
    }
    start(configs);
    if (configFile && !configFile.startsWith('node:')) {
        var restarting_1 = false;
        var aborted_1 = false;
        var configFileData_1 = fs__default.readFileSync(configFile, 'utf-8');
        var restart_1 = function () {
            var newConfigFileData = fs__default.readFileSync(configFile, 'utf-8');
            if (newConfigFileData === configFileData_1)
                return;
            configFileData_1 = newConfigFileData;
            if (restarting_1) {
                aborted_1 = true;
                return;
            }
            restarting_1 = true;
            loadConfigFile(configFile, command)
                .then(function (configs) {
                restarting_1 = false;
                if (aborted_1) {
                    aborted_1 = false;
                    restart_1();
                }
                else {
                    watcher.close();
                    start(configs);
                }
            })
                .catch(function (err) {
                handleError(err, true);
            });
        };
        configWatcher = fs__default.watch(configFile, function (event) {
            if (event === 'change')
                restart_1();
        });
    }
}

function runRollup(command) {
    if (command._.length >= 1) {
        if (command.input) {
            handleError({
                code: 'DUPLICATE_IMPORT_OPTIONS',
                message: 'use --input, or pass input path as argument'
            });
        }
    }
    if (command.dir) {
        if (command._.length && !command._.some(function (input) { return input.indexOf('=') !== -1; })) {
            command.input = command._;
        }
        else if (command._.length ||
            Array.isArray(command.input) ||
            typeof command.input === 'string') {
            var input = void 0;
            if (command._.length)
                input = command._;
            else
                input = typeof command.input === 'string' ? [command.input] : command.input;
            command.input = {};
            input.forEach(function (input) {
                var equalsIndex = input.indexOf('=');
                var value = input.substr(equalsIndex + 1);
                var key = input.substr(0, equalsIndex);
                if (!key) {
                    key = nameWithoutExtension(path.basename(input));
                }
                command.input[key] = value;
            });
        }
        command._ = [];
    }
    else if (command._.length === 1) {
        command.input = command._[0];
    }
    if (command.environment) {
        var environment = Array.isArray(command.environment)
            ? command.environment
            : [command.environment];
        environment.forEach(function (arg) {
            arg.split(',').forEach(function (pair) {
                var _a = pair.split(':'), key = _a[0], value = _a[1];
                if (value) {
                    process.env[key] = value;
                }
                else {
                    process.env[key] = String(true);
                }
            });
        });
    }
    var configFile = command.config === true ? 'rollup.config.js' : command.config;
    if (configFile) {
        if (configFile.slice(0, 5) === 'node:') {
            var pkgName = configFile.slice(5);
            try {
                configFile = requireRelative_1.resolve("rollup-config-" + pkgName, process.cwd());
            }
            catch (err) {
                try {
                    configFile = requireRelative_1.resolve(pkgName, process.cwd());
                }
                catch (err) {
                    if (err.code === 'MODULE_NOT_FOUND') {
                        handleError({
                            code: 'MISSING_EXTERNAL_CONFIG',
                            message: "Could not resolve config file " + configFile
                        });
                    }
                    throw err;
                }
            }
        }
        else {
            // find real path of config so it matches what Node provides to callbacks in require.extensions
            configFile = fs.realpathSync(configFile);
        }
        if (command.watch)
            process.env.ROLLUP_WATCH = 'true';
        loadConfigFile(configFile, command)
            .then(function (configs) { return execute(configFile, configs, command); })
            .catch(handleError);
    }
    else {
        return execute(configFile, [{ input: null }], command);
    }
}
function execute(configFile, configs, command) {
    if (command.watch) {
        watch(configFile, configs, command, command.silent);
    }
    else {
        return sequence(configs, function (config) {
            var warnings = batchWarnings();
            var _a = mergeOptions({
                config: config,
                command: command,
                defaultOnWarnHandler: warnings.add
            }), inputOptions = _a.inputOptions, outputOptions = _a.outputOptions, deprecations = _a.deprecations, optionError = _a.optionError;
            if (deprecations.length) {
                inputOptions.onwarn({
                    code: 'DEPRECATED_OPTIONS',
                    message: "The following options have been renamed \u2014 please update your config: " + deprecations
                        .map(function (option) { return option.old + " -> " + option.new; })
                        .join(', '),
                    deprecations: deprecations
                });
            }
            if (optionError)
                inputOptions.onwarn({ code: 'UNKNOWN_OPTION', message: optionError });
            return build(inputOptions, outputOptions, warnings, command.silent);
        });
    }
}

var command = minimist(process.argv.slice(2), {
    alias: commandAliases
});
if (command.help || (process.argv.length <= 2 && process.stdin.isTTY)) {
    console.log("\n" + help.replace('__VERSION__', version) + "\n"); // eslint-disable-line no-console
}
else if (command.version) {
    console.log("rollup version " + version); // eslint-disable-line no-console
}
else {
    try {
        require('source-map-support').install();
    }
    catch (err) {
        // do nothing
    }
    runRollup(command);
}
